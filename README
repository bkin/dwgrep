-*-org-*-
* Introduction

  Dwgrep is a tool and an associated language for querying Dwarf
  (debuginfo) graphs.  If you want to find out more about Dwarf, you
  can check out the following links.  But you can also pretend that
  Dwarf is like XML, except nodes are called DIE's.  That, and
  perusing the output of eu-readelf -winfo, should be enough to get
  you started.

    http://www.dwarfstd.org/doc/Debugging%20using%20DWARF.pdf
    http://dwarfstd.org/Download.php

  You can think of dwgrep expressions as instructions describing a
  path through a graph, with assertions about the type of nodes along
  the way: that a node is of given type, that it has a given
  attribute, etc.  There are also means of expressing sub-conditions,
  i.e. assertions that a given node is acceptable if a separate
  expression matches (or doesn't match) a different path through the
  graph.

  Apart from Dwarf objects (DIE's and Attributes), dwgrep expressions
  can work with integers, strings, and sequences of other objects.

  In particular, a simple expression in dwgrep might look like this:

  : entry ?DW_TAG_subprogram child ?DW_TAG_formal_parameter @DW_AT_name

  On a command line, you would issue it like this:

  : dwgrep /some/file/somewhere -e 'entry ?DW_TAG_subprogram ...etc....'

  The query itself (ignoring the initial colon that's part of
  meta-syntax) says: show me values of attribute DW_AT_name of
  DW_TAG_formal_parameter nodes that are children of DW_TAG_subprogram
  entries (which here means debug information entries, or DIE's).
  Reading forward, you get list of instructions to a matcher: take
  DIE's, accept all DW_TAG_subprogram's, look at their children,
  accept those that are DW_TAG_formal_parameter, take value of
  attribute DW_AT_name.

  Another example comes from dwarflint:

  : entry ?DW_AT_decl_column !DW_AT_decl_line

  ... which looks for DIE's that have DW_AT_decl_column, but don't
  have DW_AT_decl_line--a semantic violation that is worth reporting.


* Overview of dwgrep language

** •“{” (“|” ID₁ ID₂ … “|”)? EXPR₁ “}” — blocks

    - {EXPR₁} -- A block syntax.  A value representing an expression
      EXPR₁ is pushed to TOS.  The enclosed expression can later be
      evaluated using an operator "apply".  Application causes EXPR₁
      to be evaluated in plain context.  Thus:
      : {add} 1 2 rot apply	# Leaves 3 on stack.
      : {1 add} 2 swap apply	# Likewise.

    - {|ID₁ ID₂ …| EXPR₁} -- A variant of block syntaxt with an
      identifier block.  When applied, pops TOS and binds it to the
      rightmost identifier, and then proceeds doing the same with
      other identifiers in right to left direction.

      : {|A B| A B add A B sub mul} 3 1 rot apply	# 8

    - When a block is applied, this introduces a new activation record
      (dynamic scope) inside the current scope.  Any let forms bind
      symbols in this new scope.  Upon creation, block literals copy
      values of referenced variables into their scope, so they work as
      closures:

      : let adder := {|x| {|y| x y add}};
      : 3 adder 2 swap apply	# 5

      : let map := {|L f| [L elem f]};
      : [1, 2, 3] {1 add} map	# [2, 3, 4]

    - Because blocks copy surrounding context instead of referencing
      it, all referenced bindings need to be defined at the point of
      block creation.  That precludes a simple way of writing
      recursive functions:

      : # This doesn't work:
      : let fact := {|N| if (N < 2) then 1 else (N 1 sub fact N mul)};

      Here "fact" is referenced inside the block, but at that point,
      it has not yet been defined, and such expression is thus
      erroneous.  It is possible to express recursion, even mutual
      recursion:

      : let f1 := {|N f1 f2|
      :    if (N < 100) then (
      :        N sub 1
      :        {f1} {f2} f2 apply	# recurse to f2
      :    ) else (N)
      : };
      :
      : let f2 := {|N f1 f2|
      :     if (N > 0) then (N mul: 2) else (N)
      :     {f1} {f2} f1 apply		# recurse to f1
      : };
      :
      : 5 {{f1}} {{f2}} f1	# 194

      ... but that is of course ridiculous.  The hope is that
      recursion is rarely useful in a language like this, which is
      meant for querying, not writing algorithms.  Should there be
      serious need for this sort of thing, this functionality would be
      introduced.

    - Example: stack shuffling operators.  (N.B.: this example uses
      underscores to distinguish from the corresponding built-in
      words.   Redefining built-ins is not allowed.)
      : let drop_ := {|a|};
      : let dup_ := {|a| a a};
      : let swap_ := {|a b| b a};
      : let rot_ := {|a b c| b c a};
      : let over_ := {|a b| a b a};

**  (“while” | “until”) EXPR₀ “do” EXPR₁ | “do” EXPR₁ (“while” | “until”) EXPR₀

   - The "while..do" loop checks whether EXPR₀ yields anything.  If
     yes, it evaluates EXPR₁ and repeats; otherwise it doesn't do
     anything.

     "do..while" works similarly, but it first evaluates EXPR₁ and
     then tests whether EXPR₀ yields anything.

     "until" loops work similarly, but test a reverse condition.

   - EXPR₀ is evaluated in sub-expression context.
   - EXPR₁ shall have neutral stack effect.

** •“\dbg” — debug print

    Doesn't alter the stack in any way, but as a side effect prints
    some information about the computation in whose context it
    appeared.

** •colon infix syntax
    - When a word is followed by a colon, the following statement is
      executed before that word.  That can be used for writing the
      operators, where it makes sense, in infix form.  For example:
      : 10 add: 1	# equivalent to (10 1 add)
      : [10 range] sort: {a | if (a mod: 2 == 0) then 0 else 1}


* Fundamental words
** •dup, over, swap, rot, drop — stack shuffling
   These words reorder elements on stack according to the following
   schemes:

   |------+---------+-----------|
   | op   | before  | after     |
   |------+---------+-----------|
   | dup  | A B C D | A B C D D |
   | over | A B C D | A B C D C |
   | swap | A B C D | A B D C   |
   | rot  | A B C D | A C D B   |
   | drop | A B C D | A B C     |
   |------+---------+-----------|

   Realistically, most of what end users should write will be an
   occasional dup, possibly a swap.  Drop shouldn't be needed (that's
   what sub-expressions are for), and the deep stack manipulation
   should be unnecessary as well.  But they are present for
   completeness' sake.

** •type :: ?() -> ?T_CONST
   This produces a constant according to the type of value on TOS
   (such as T_CONST, T_DIE, T_STR, etc.).

** •pos :: ?() -> ?T_CONST
    Each function numbers elements that it produces, and stores number
    of each element along with the element.  That number can be
    recalled by saying "pos".

    If you wish to know the number of values produced, you have to
    count them by hand:
    : [ child ] let L := length; elem

** •?eq, ?ne, ?gt, ?ge, ?lt, ?le :: ?() ?()
    These are low-level assertions that can be used instead of ==, !=,
    etc.

    Two elements are inspected: TOS and one below that (B and A,
    respectively).  The assertion holds if A op B is true.  Comparing
    values of different types is not defined, and such assertions fail
    as well.

    Note that there is both !eq and ?ne, !lt and ?ge, etc.  These are
    mostly for symmetry--the assertions need "?" to denote that they
    are assertions, so why not have "!" forms as well.  For !eq it
    even makes a good sense.


* Words for intrinsic types
** ·T_CONST
*** •value :: ?T_CONST -> ?T_CONST
     Returns underlying value of the constant, with plain domain.
     : DW_FORM_flag value	# gives 12

*** •add, sub, mul, div, mod :: ?T_CONST ?T_CONST -> ?T_CONST
     Two elements are popped: A and B, with B the original TOS, and "A
     op B" is pushed again.

     division and modulo by zero produce an error message and abort
     current computation.

*** •hex, oct, bin :: ?T_CONST -> ?T_CONST
     These yield incoming stack, except the domain of constant on TOS
     is changed.
     : 64 hex		# gives 0x40
     : DW_AT_name hex	# gives 0x3

     The value remains a constant, only the way it's displayed
     changes.  You can use "%s" to convert it to a string, in which
     case it's rendered with the newly-selected domain.
     : DW_AT_name "%s"		# gives "DW_AT_name"
     : DW_AT_name hex "%s"	# gives "0x3"

***  int32_t, uint32_t, int64_t, uint64_t :: ?T_CONST -> ?T_CONST
     The idea behind uint32_t et.al. is that a two-complement
     representation of a given constant is taken, if necessary, it's
     sign-extended, and then a 32-bit or 64-bit slice of that is
     taken, and that is reinterpreted as either a signed or unsigned
     value:

     : -1 hex			# gives -0x1
     : -1 uint32_t hex		# gives 0xffffffff
     : -1 uint64_t hex		# gives 0xffffffffffffffff
     : 0xffffffff int32_t	# gives -1
     : 0xffffffffff int32_t	# gives -1 as well
     : 0xffffffff int64_t	# gives 0xffffffff

     Maybe what we want instead is "32 uint", "64 int" etc., such that
     bit length is configurable.

***  intptr_t, uintptr_t :: ?T_CONST -> ?T_CONST
     {,u}intptr_t then expands to either of {,u}int{64,32}_t depending
     on address size of CU.  XXX how to get to that size?  What
     should, say, "17 uintptr_t" do?  There's no CU in sight...

** ·T_SEQ
*** •add :: ?T_SEQ ?T_SEQ -> ?T_SEQ
     Concatenates two sequences.

*** •elem :: ?T_SEQ ->* ?()
     Pops a list, and for each element yield a stack with that element
     pushed on top.

     To zip contents of two top lists near TOS, do:
     : ->A B; A elem B elem (pos == swap pos)

     This takes two lists from the stack, and produces stacks that
     have those lists replaced with individual elements that
     correspond to each other.  For example:
     : A B [C₁, C₂, C₃] [D₁, D₂, D₃]

     ... would be replaced with three stacks:
     : (A B C₁ D₁, A B C₂ D₂, A B C₃ D₃)

*** •relem :: ?T_SEQ ->* ?()
     This is like elem, but yields elements in reverse order.

*** •length :: ?T_SEQ -> ?T_CONST
     Yields length of sequence on TOS.

*** •?empty :: ?T_SEQ
     Asserts whether a sequence on TOS is empty.

*** •?find :: ?T_SEQ ?T_SEQ
    (A B find) asserts that the sequence A contains sub-sequence B
    (e.g. [hay stack] ?([needle] ?find)).

    To determine whether a sequence contains a particular element, you
    would use the following construct:
    : [that sequence] (elem == something)

    E.g.:
    : [child @AT_name] ?(elem == "foo")
    : [child] ?(elem @AT_name == "foo")

    To pick only those elements that match, you could do the
    following:
    : [child] [|L| L elem ?(@AT_name ?"foo")]

    The above is suitable for a function that takes a list on input
    and wants to filter it.  It is of course preferable to write this
    sort of thing directly, if possible:
    : [child ?(@AT_name ?"foo")]

*** •?starts :: ?T_SEQ ?T_SEQ
    (A B starts) asserts that the sequence A starts with sub-sequence B
    (e.g. [hay stack] ?([needle] ?starts)).

*** •?ends :: ?T_SEQ ?T_SEQ
    (A B ends) asserts that the sequence A ends with sub-sequence B
    (e.g. [hay stack] ?([needle] ?ends)).

***  at :: ?T_SEQ ?T_CONST -> ?()

     One can access a particular element by enumerating the array with
     elem or relem, and then do assertions on pos:

     : [some seq] elem (pos == 0)	# [0]
     : [some seq] relem (pos == 0)	# [-1]
     : [some seq] elem (pos != 0)	# [1:]
     : [some seq] elem (pos >= 3 && pos < 6)	# [3:6]
     : [some seq] relem (pos > 0)	# [:-1]

     I don't suppose array operations will be widely used, so maybe
     this is just fine.  Most of the time, instead of producing a
     sequence, you would just assert position on the producing
     expression directly.

     If it turns out to be useful, we can adopt an "at" word, which
     would follow Python indexing conventions:

     : [some seq] at: 0		# elem (pos == 0)
     : [some seq] at: -1	# relem (pos == 0)

     We could also have:
     -- slice :: ?T_SEQ ?T_CONST ?T_CONST -> ?()
     -- slice :: ?T_SEQ ?T_CONST -> ?()

     : [some seq] 1 slice	# elem (pos != 0)
     : [some seq] 3 6 slice	# elem (pos >= 3 && pos <= 5)
     : [some seq] 0 -1 slice	# relem (pos > 0)

     We would need both versions because there's no placeholder like
     None in Python, where [1:] means [1:None] and None is treated
     like one past last element.  0 can't be used in that capacity, as
     then it wouldn't be clear whether (0 0 slice) needs to yield
     nothing or everything.

***  fold :: ?T_SEQ ?() ?T_CLOSURE ->* ?()
     - This takes care of all sorts of summing and joining list
       elements.  E.g. "join" is:
       : [the sequence] "" {"%s" add} fold
       "sum" is:
       : [the sequence] 0 {add} fold

***  rfold :: ?T_SEQ ?() ?T_CLOSURE ->* ?()
     - Like fold, but works in reverse.

***  fold1 :: ?T_SEQ ?T_CLOSURE ->* ?()
     : let fold1 := {|L C| L (L elem (pos == 0)) {C} fold};
     - I.e. takes initial value from the sequence.  Produces nothing
       if the sequence is empty.

***  rfold1 :: ?T_SEQ ?T_CLOSURE ->* ?()
     - Like fold1, but in reverse order.

** ·T_STR
    Many words, applicable to sequences, are applicable to strings as
    well.  The semantics are as if the string was a sequence of all
    the constituent characters (the characters themselves are again of
    type T_STR).  The prototypes are as if T_SEQ was replaced with
    T_STR.

*** •add (as T_SEQ)
*** •elem (as T_SEQ)
*** •relem (as T_SEQ)
*** •length (as T_SEQ)
*** •?empty (as T_SEQ)
*** •?find (as T_SEQ)
*** •?starts (as T_SEQ)
*** •?ends (as T_SEQ)
*** •?match :: ?T_STR ?T_STR
     This asserts that TOS (which is a string with a regular
     expression) matches the value below TOS.  The whole string has to
     match.  If you want to look for a regular expression inside the
     string, you can say ("haystack" ?(".*needle.*" ?match)).

***  match :: ?T_STR ?T_STR ->* ?T_STR
     - This should work like ?match, but would produce match objects
       with individual groups.
       : "abcd" r"(\w)(\w)" ...
       : ... match			# two matches
       : ... match low			# 0 and 2
       : ... match high			# 2 and 4
       : ... match value		# "ab" and "cd"
       : ... match (pos==0) elem	# match for "a" and match for "b"
       : ... match (pos==0) elem value	# "a" and "b"

***  demangle :: ?T_STR -> ?T_STR

** •T_CLOSURE
*** •apply :: T_CLOSURE ->
     The block on TOS is executed.


* Representation of Dwarf graph
** Vocabulary
   - elem, relem, length -- container-like access
   - child, parent -- vertical tree access
   - next, prev -- horizontal tree access
   - root -- access to root tree element
   - high, low -- boundaries
   - label -- node denotation (attribute code, DIE tag, ...)
   - abbrev -- access to abbreviation(s)
   - attribute -- access to attribute(s)
   - form -- attribute form (a DW_FORM_* constant)
   - name -- string associated with entity (file name, symbol name)
   - offset -- constant describing where in the file the object is
     defined
   - address -- address(es) of where in user space the object is
     defined
   - merge -- re-establish logical view of the whole
   - entry -- access to entries of a unit
   - unit -- access to unit

** ·Entry points
*** ·dwopen :: ?T_STR -> ?T_DWARF
     - Pops a file name, opens an ELF with that name, and pushes a
       value representing that file to TOS.

     - When files are passed on command line, those are pre-opened and
       pre-pushed by the query driver, and appear as sole value on
       runtime stack:
       : $ dwgrep ./a.out -e 'type'
       : T_DWARF

** ·T_DWARF
*** •entry :: ?T_DWARF ->* ?T_DIE
      - Yields all DIE's in a .debug_info section.

*** •unit :: ?T_DWARF ->* ?T_CU
     : entry ?root unit

*** •abbrev :: ?T_DWARF ->* ?T_ABBREV_UNIT
     - Yields all abbreviation units in a .debug_abbrev section.

***  symbol :: ?T_DWARF ->* ?T_ELFSYM
     - Yields all symbols in .symtab, or minisymtab, or .dynsym.

*** •name :: ?T_DWARF -> ?T_STR

** ·T_CU
*** •offset :: ?T_CU -> ?T_CONST
***  next :: ?T_CU ->? T_CU
***  prev :: ?T_CU ->? T_CU
*** •abbrev :: ?T_CU -> ?T_ABBREV_UNIT
     - Produce an abbreviation unit associated with this CU.

*** •version :: ?T_CU -> ?T_CONST
*** •entry :: ?T_CU ->* ?T_DIE
     : root child*	# except in the right order

*** •root :: ?T_CU -> ?T_DIE
     - Produce a CU DIE of a CU.

** ·T_DIE
*** •label :: ?T_DIE -> ?T_CONST
     Yields DIE tag.

*** •offset :: ?T_DIE -> ?T_CONST
     Like dwarf_dieoffset.

*** •unit :: ?T_DIE -> ?T_CU
     - Selects unit that this DIE comes from.

*** •high :: ?T_DIE ->? ?T_CONST
     : attribute ?AT_highpc address

*** •low :: ?T_DIE ->? ?T_CONST
     : @AT_lowpc

*** •address :: ?T_DIE ->? ?T_ASET
     Like dwarf_ranges.

*** •child :: ?T_DIE ->* ?T_DIE
     Yields children of the DIE.

*** •attribute :: ?T_DIE ->* ?T_ATTR
     Yields attributes of the DIE.

*** •parent :: ?T_DIE ->? ?T_DIE
     Yields the parent of the DIE, if there's any.

     XXX DW_TAG_partial_unit

*** •root :: ?T_DIE -> ?T_DIE
     : root := {parent* !(parent)};

*** •?root :: ?T_DIE
     ?root holds if the DIE is a root node.  Equivalent to !(parent).
     : parent* ?root        # finds a root node of node on TOS

***  next :: ?T_DIE ->? ?T_DIE
     Like dwarf_siblingof, returns next sibling of the DIE.

     : def next {|D| D parent child (pos == D parent child (== D) pos 1 add)}

     The first line is necessary to make sure that pos later refers
     to order in children array, not to e.g. a result of ([XYZ] each).

***  prev :: ?T_DIE ->? ?T_DIE
     The opposite of next.

***  merge :: ?T_DIE ->* ?T_DIE
     : let merge := { ?DW_TAG_imported_unit @AT_import child+ };

     A typical use would then be:
     : entry merge*		# if you want to see deref'd DIE's
     : entry merge* !(merge)	# if you care about the actual tree

     XXX But that is fairly impractical, as one would have to use such
     operation after each DIE traversal (in particular after every
     (child) traversal).  You actually rarely need the (entry merge*)
     thing above, because it already is the case that (entry) visits
     everyone.  If you need anything at all, it is more likely to be:
     : entry !(merge)

     ... so that you filter out partial unit headers.

     A better approach could be to have two types for DIE-related
     elements--raw and cooked DIE's, raw and cooked CU's, etc.  Raw
     values don't do attribute integration, don't inline imported
     units and present attribute values as offsets instead of the
     referenced thing.  Words (cooked) and (raw) switch between the
     two types.  The default types would be "cooked".

     It's not clear yet whether attributes that even raw DIE's yield
     shouldn't be cooked implicitly, as things like getting string or
     DIE offset instead of the thing itself seem rarely useful.Dwarf's.

     Cooked DIE's will also have to keep track of the original DIE
     where the partial unit import took place, so that when you ask
     for (parent), you travel back to where you came from without
     trouble, as if the whole thing were one monolithic unit.

     (unit) on cooked Dwarf would skip partial units.  (entry) would
     descend through CU's and include partial units this way, so that
     the logical tree is presented in its whole, and parent/child
     paths are preserved.

*** •@AT_decl_file
     Value of this attribute is represented as actual string including
     path.

     (XXX we ignore mtime and size.  Those aren't stored anyway, but
     maybe it would be useful to have them so that one can do this
     sort of querying in the first place--do we have any files where
     this is stored?  Or after it gets to be stored in general, where
     this is _not_ stored?)

*** •abbrev :: ?T_DIE -> ?T_ABBREV
     Yield abbreviation associated with this DIE.

*** •name :: ?T_DIE -> ?T_STR
     : @AT_name

*** •@AT_* :: ?T_DIE ->* ?()
     Syntactic sugar for (attribute ?(label == AT_*) value).

*** •?AT_* :: ?T_DIE
     Holds if DIE has this attribute.

*** •?TAG_* :: ?T_DIE
     Holds if DIE has this tag.

***  ?LANG_* :: ?T_DIE
     Holds if (@AT_language == DW_LANG_*).

***  ?ATE_* :: ?T_DIE
     Holds if @AT_encoding == DW_ATE_*.

***  ?haschildren :: ?T_DIE
     : abbrev ?haschildren
     Note that to find out whether a DIE actually does have children,
     one asks simply ?(child).

** ·T_ATTR
*** •label :: ?T_ATTR -> ?T_CONST
     Yield an attribute name.

*** •value :: ?T_ATTR ->* ?()
     Yields value(s) of attribute on TOS.

     Some attributes refer to a location expression.  These are
     represented as a number of nodes of type T_LOCLIST_ELEM.
     Children of these nodes are T_LOCLIST_OP, individual operations
     of location expression.

*** •address :: (?T_ATTR (?AT_high_pc||?AT_low_pc||?FORM_addr)) -> ?T_CONST
     - For DW_AT_high_pc, DW_AT_entry_pc with constant forms, this
       converts the value to address.

     - For attributes with address form, this is like calling "value".

     - Otherwise it is an error to use this.

*** •form :: ?T_ATTR -> ?T_CONST
     Yield a form of an attribute.

*** •die :: ?T_ATTR -> ?T_DIE
     - Yield a DIE that this attribute is associated with.

*** •unit :: ?T_ATTR -> ?T_CU
     : die unit

*** •?AT_* :: ?T_ATTR
     Holds if it is this attribute.

*** •?FORM_* :: ?T_ATTR
     Holds if the attribute has this form.

***  ?LANG_* :: ?T_ATTR
     Holds if (?AT_language value == DW_LANG_*).

***  ?ATE_* :: ?T_ATTR
     Holds if (?AT_encoding value == DW_ATE_*)

** ·T_ABBREV_UNIT
*** •offset :: ?T_ABBREV_UNIT -> ?T_CONST
     - Yield offset of this abbreviation unit.

*** •entry :: ?T_ABBREV_UNIT ->* ?T_ABBREV
     - Yield abbreviations defined in this unit.
       XXX this is currently done by elem.

** •T_ABBREV
*** •label :: ?T_ABBREV -> ?T_CONST
*** •offset :: ?T_ABBREV -> ?T_CONST
*** •attribute :: ?T_ABBREV ->* ?T_ABBREV_ATTR
     - Yields all abbreviation attributes.

*** •code :: ?T_ABBREV -> ?T_CONST
     - Yields abbreviation code.

***  unit :: ?T_ABBREV -> ?T_ABBREV_UNIT
     - Yield an abbreviation unit that this abbreviation comes from.

*** •?TAG_* :: ?T_ABBREV
     Holds if abbreviation has this tag.

*** •?AT_* :: ?T_ABBREV
     Holds if abbreviation has this attribute.

*** •?haschildren :: ?T_ABBREV
     - Holds for abbreviations that form child-ful DIE's.

** •T_ABBREV_ATTR
*** •label :: ?T_ABBREV_ATTR -> ?T_CONST
     Yields attribute name.

*** •offset :: ?T_ABBREV_ATTR -> ?T_CONST
     Yields offset of attribute within abbreviation.

*** •form :: ?T_ABBREV_ATTR -> ?T_CONST
     Yields attribute form.

*** •?AT_* :: ?T_ABBREV_ATTR
     Holds if it is this attribute.

*** •?FORM_* :: ?T_ABBREV_ATTR
     Holds if the attribute has this form.

**  T_ELFSYM
***  label :: ?T_ELFSYM -> ?T_CONST
     Yields symbol type, such as STT_FUNC.

***  address :: ?T_ELFSYM -> ?T_ASET
     Yield symbol value.

***  name :: ?T_ELFSYM -> ?T_STR
***  size :: ?T_ELFSYM -> ?T_CONST
***  bind :: ?T_ELFSYM -> ?T_CONST
***  vis :: ?T_ELFSYM -> ?T_CONST
***  index :: ?T_ELFSYM ->? ?T_CONST
     XXX or maybe @section?

***  symbol :: ?T_CONST ->? T_ELFSYM
     This find a symbol associated with an address on TOS.  The match
     doesn't have to be exact, offset would then be:
     : let A := some addr; A symbol dup address A sub
     :  # now TOS has offset and below TOS is symbol

     XXX some of this is fairly easy to get by cross-matching like
     this:
     : symtab (address == some addr)
     fuzzy matching (getting symbol/offset) would be more involved.

** •T_LOCLIST_ELEM
*** •address :: ?T_LOCLIST_ELEM -> ?T_ASET
     Yields where given location expression applies.

*** •elem :: ?T_LOCLIST_ELEM ->* ?T_LOCLIST_OP
     Yields individual location expression operators.

*** •relem :: ?T_LOCLIST_ELEM ->* ?T_LOCLIST_OP
     Like elem, but yields in opposite direction.

*** •?OP_* :: ?T_LOCLIST_ELEM
     Holds if this location expression contains an operation with this
     opcode.

** •T_LOCLIST_OP
*** •label :: ?T_LOCLIST_OP -> ?T_CONST
     Yields operation opcode (a DW_OP_* constant).

*** •offset :: ?T_LOCLIST_OP -> ?T_CONST
     Yields an offset of this op within the location expression.

*** •value :: ?T_LOCLIST_OP ->* ?()
     Yields operands associated with this location expression
     operation.  Operands have anywhere between zero and two operands
     of various types (some are e.g. T_DIE references).

     For example:

     : [4e] variable
     :      [...]
     :      location (exprloc) [0x0..0xffffffffffffffff, [0:fbreg<-18>]]

     Here we have only one T_LOCLIST_OP, and that has an offset of 0, a
     label of DW_OP_fbreg, and yields one value, -18.

*** •?OP_* :: ?T_LOCLIST_OP
     Holds if this is an operation with this opcode.

** •T_ASET
    - For holding a set of addresses.

*** •add :: ?T_ASET ?T_CONST -> ?T_ASET
*** •add :: ?T_ASET ?T_ASET -> ?T_ASET
*** •sub :: ?T_ASET ?T_CONST -> ?T_ASET
*** •sub :: ?T_ASET ?T_ASET -> ?T_ASET
*** •aset :: ?T_CONST ?T_CONST -> ?T_ASET
*** •range :: ?T_ASET ->* ?T_ASET
     - Extract continuous subranges of this aset and present them as
       individual asets.

*** •high :: ?T_ASET ->? ?T_CONST
     Highest address set in this aset.  Doesn't yield at all if an
     aset is empty.

*** •low :: ?T_ASET ->? ?T_CONST
     Lowest address set in this aset.  Doesn't yield at all if an aset
     is empty.

*** •length :: ?T_ASET -> ?T_CONST
     : [|A| address] length

*** •?empty :: ?T_ASET
     : !(elem)

*** •?overlaps :: ?T_ASET ?T_ASET
     - Holds if there is at least one value common to both osets.

*** •?contains :: ?T_ASET ?T_CONST
     : ?(|A C| A elem (|E| (C >= E low) (C <= E high)))

*** •?contains :: ?T_ASET ?T_ASET
     - Holds if the lower aset contains all addresses of the TOS aset.
     : !(address !contains)

*** •overlap :: ?T_ASET ?T_ASET -> ?T_ASET
     Compute aset that contains addresses common to both asets.
     Produces an empty aset if there's no overlap.

*** •elem :: ?T_ASET ->* ?T_CONST
     - Actually enumerates all addresses in a range.  Potentially a
       very bad idea for ranges that cover whole address space.

*** •relem :: ?T_ASET ->* ?T_CONST
     : [|A| A elem] relem

**  T_MACRO_UNIT ???
    - A value representing .debug_macro and .debug_macinfo units.
      Might be useful for DW_MACRO_GNU_transparent_include opcode, and
      for DW_AT_macro_info and DW_AT_GNU_macros attributes, which
      would hold this as a value.

***  entry :: ?T_MACRO_UNIT ->* ?T_MACRO_ENTRY
***  offset :: ?T_MACRO_UNIT ->* ?T_CONST
***  XXX :: something to get the prototype table???

**  T_MACRO_ENTRY
    - A value used for representing both .debug_macro and
      .debug_macinfo entries.  Domain of entry label disambiguates
      which is which.

***  label :: ?T_MACRO_ENTRY -> ?T_CONST
     - Opcode of this macro entry.

***  attribute :: ?T_MACRO_ENTRY ->* ?T_MACRO_ATTRIBUTE
     - Yields value(s) associated with this opcode.
     - XXX could we somehow query a form?

***  merge :: ?T_MACRO_ENTRY ->* ?T_MACRO_ENTRY
     : let merge := { ?DW_MACRO_GNU_transparent_include value };

     Should be used as with DIE's, depending on what exactly is needed
     either (merge*) or (merge* !(merge)).

***  @0, @1, ... or something???
     - Should this resemble DIE's or T_LOCLIST_OP's?  Shouldn't
       T_LOCLIST_OP's actually resemble DIE's as well?  @X as a
       shorthand for (value (pos == X)) seems fairly natural.

       If X is a name instead of a number, it means:
       : (attribute (label == X))

**  T_MACRO_ATTRIBUTE ???
    - Note that label is explicitly not applicable
***  value
***  form


* Examples

** Josh Stone's nontrivial-parameters script

   : let A := entry ?TAG_subprogram !AT_declaration
   :          ?(@AT_decl_file (=~ "^/usr/") (!~ "^/usr/src/debug"));
   :
   : let B := A child ?TAG_formal_parameter
   :          ?(@AT_type ((?TAG_const_type, ?TAG_volatile_type, ?TAG_typedef)
   :            @AT_type)* (?TAG_structure_type, ?TAG_class_type));
   :
   : "%( A @AT_decl_file %): %( A @AT_decl_line %): note: in function "\
   : "`%( A @AT_name %)', parameter `%( B @AT_name %)' type is not trivial"

** check_die_decl_call:
   : (entry ?AT_decl_column !AT_decl_line "%s has decl_column, but NOT decl_line"
   : , etc.)

** check_die_line_info:
   : let A := entry (?TAG_subprogram, ?TAG_inlined_subroutine, ?TAG_entry_point,
   :                ?TAG_lexical_block, ?TAG_label, ?TAG_with_stmt,
   :                ?TAG_try_block, ?TAG_catch_block);
   : let B := A (@AT_entry_pc, address);
   : let C := A root address;
   : ?(B C !overlaps || B C overlap != B)
   : "Address range %( B %) referenced from %( A %)"\
   : " not fully covered by line table."

** contains DW_OP_fbreg && ! @frame_base
   : entry !AT_frame_base (@AT_location elem label == DW_OP_fbreg)

** uses register based operators

   : entry ?(@AT_location elem label
   :         (== DW_OP_bregx || (>= DW_OP_reg0) (<= DW_OP_regx)))

   : entry ?(@AT_location elem label "%s" "_b?reg" ?find)

** whether it uses a deref operator

   : entry ?(@AT_location elem label (?OP_deref, ?OP_xderef, ?OP_deref_size,
   :                                  ?OP_xderef_size, ?OP_GNU_deref_type))

   : entry ?(@AT_location elem label "%s" "deref" ?find)

** contains DW_OP_call_frame_cfa && $@low_pc == 0

   : entry (@AT_low_pc == 0) ?(@AT_frame_base ?OP_call_frame_cfa)

** is an empty location expression

   : entry ?(@AT_location !(elem))

** location expression ends with implicit_value or stack_value

   : entry ?([@AT_location] relem (pos == 0) label
   :         (?DW_OP_implicit_value, ?DW_OP_stack_value))

** types inconsistent between instance and specification
   - http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43053

     : let A := entry ?TAG_subprogram;
     : let B := A child ?TAG_formal_parameter;
     : let C := A @AT_specification child ?TAG_formal_parameter;
     : (B pos == C pos) (B @AT_type != C @AT_type) A

** duplicat DW_TAG_const_type
   - http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56740

     : # Leaves on stack two DIE's that describe the same type.
     : let A := entry (?TAG_const_type||?TAG_volatile_type||?TAG_restrict_type);
     : A root child* (> A) (label == A label) (@AT_type == A @AT_type) A

** find any attribute with value "blah"
   : attribute (value == "blah")

** check_duplicate_DW_tag_variable.cc
   Check for two full DW_TAG_variable DIEs with the same DW_AT_name
   value.

   : entry ?TAG_variable (@AT_name == next+ ?TAG_variable @AT_name)

** check_linkage_external_die.cc

     : (|Dw|
     :  let GetSym := {|X| Dw symtab (?STT_OBJECT, ?STT_FUNC)
     :                     (@name == X @AT_linkage_name)};
     :  Dw entry ?AT_linkage_name
     :  if !(GetSym) then (
     :      !AT_declaration !AT_const_value
     :      (!structure_type !enumeration_type !union_type, ?AT_name)
     :      "%s has linkage_name attribute that's not in symtab, "\
     :      "but is not marked as declaration"
     :  ) else if (GetSym ?STB_LOCAL) then (
     :      !AT_declaration ?AT_external
     :      "%s has linkage_name attribute, "\
     :      "but the corresponding symbol is local"
     :  ) else (
     :      !AT_external
     :      "%s has linkage_name attribute, but no external attribute"
     :  ))

   This is still 1:10 vs. dwarflint C++ (i.e., say 1:20 if we had to
   explore the DIE tree by hand), but fairly involved.

   The interpreter would need to notice the ?symbol nodes are used as
   a sort of global variable for cross-referencing, otherwise this
   would lead to an ugly combinatorial explosion of states.  Noticing
   that we look at the bottom slot and cross-reference @AT_name with
   @AT_linkage_name should be possible.

   An alternative start would be something like:
   : let Dw := $1 dwopen;

** CU A imports two PU's B and C, and both import the same third PU

   : let imports := {root child ?TAG_imported_unit @AT_import};
   :
   : let U := entry ?root ;
   : let A := U child ?TAG_imported_unit @AT_import ;
   : let B := U child ?TAG_imported_unit @AT_import (> A) ;
   : A imports B imports (== swap)
   : "PU %(offset%) is imported by PU's %(A offset%) and %(B offset%), "\
   : "which are both imported by %(U offset%)."

** typedef resolution
   - dsmith asked for a way to get typedef "resolution" from DWARF
     (for use with the syscall types in the kernel). Which was timely
     since I was just thinking about having some "roundtripping" tests
     for GCC/elfutils DWARF types. So hacked up a dwfltypedef that
     prints all (C) typedefs found:

     $ ./dwfltypedef -e ./dwfltypedef
     [2d] typedef size_t long unsigned int (unsigned, 8 bytes);
     [70] typedef __off_t long int (signed, 8 bytes);
     [7b] typedef __off64_t long int (signed, 8 bytes);
     [...]

     : let T := entry ?TAG_typedef ;
     : let U := T @AT_type (?TAG_typedef @AT_type)* !TAG_typedef ;
     : "[%(T offset%)] typedef %(T @AT_name%) %(U @AT_name%) "\
     : "(%( U @AT_encoding || "???" %), %( U @AT_byte_size || "???" %) bytes)"

     [0x57] typedef __int32_t int (DW_ATE_signed, 4 bytes)
     [0x70] typedef __off_t long int (DW_ATE_signed, 8 bytes)
     [0x7b] typedef __off64_t long int (DW_ATE_signed, 8 bytes)
     [0x9c] typedef __intptr_t long int (DW_ATE_signed, 8 bytes)
     [0xa7] typedef size_t long unsigned int (DW_ATE_unsigned, 8 bytes)
     [...]

** nested identifier names
   : (@AT_name == "a") child (@AT_name == "b") child (@AT_name == "c")
