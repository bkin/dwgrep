-*-org-*-
* Computation

  Dwgrep is tool and an associated language for querying Dwarf graphs.
  Conceptually, expressions of this language are a pipeline of
  functions.  The Dwarf graph under consideration flows through this
  pipeline, modified by each function of the overall expression, and
  whatever comes out of the other end is the result of the query.

  We call what flows through the dwgrep expression a /working set/.
  Initial working set contains all DIE's in a given Dwarf graph.  As
  the working set is transformed, its elements can be more than just
  DIE's--they can be of any of the following types:

  - Dwarf DIE's
  - integers, strings
  - sequences of other values

  Each function takes on input an element of the working set, and
  produces zero or more values on the output.  Note that producing
  several values is different from producing a single value of type
  sequence.  When a function is applied on a working set element, the
  following can happen:

  - that element is removed (if a function doesn't return any value)
  - the value stored at that element is changed for another
  - that element is "forked", replaced with several elements, each
    with one value that the function produced

  There is a subtle difference between values and elements that will
  be clarified later.  For now you can think of the two as synonyms.

  When dwgrep expression is evaluated, the functions in the expression
  are applied to each element of the working set, and the output is
  collected to form a new working set.  The whole scheme is thus
  reminiscent of shell pipeline, except you have richer variety of
  types instead of lines.

* Introduction to the dwgrep language

  In following, examples are generally written as follows:

  : blah blah lorem ipsum stuff

  The initial colon is not part of the example, but an artifact of
  Emacs org mode.

** ?ID — Filtering DIE's by tag

   The predicate "?ID" holds for DIE's whose tag is DW_TAG_ID.  This
   functions returns its input element, if it has the given tag.

   For example, to list all subprograms, one would use the following
   expression:

   : ?subprogram

** ?@ID — Filtering DIE's by attribute
** PRED₁ && PRED₂, PRED₁ || PRED₂, !PRED — the usual logical connectives

   "?@ID" is a predicate that holds for DIE's with an attribute
   DW_AT_ID.  To list all subprograms that are not pure declarations,
   one would use the following expression:

   : ?subprogram && ! ?@declaration

** (EXPR) — we can parenthesize for clarity or precedence
** / — child traversal

   Function "/" produces children DIE's of a given DIE.  If applied on
   a childless DIE or on a value that's not DIE at all, it produces
   nothing, and such elements are thus dropped.

   To get at the formal arguments of the subprograms from the previous
   example, one might say:

   : (?subprogram && ! ?@declaration) /

** EXPR₁ EXPR₂ … — pipeline formation

   In dwgrep, pipelines are formed by simply placing each function
   next to each other.  This can be seen in the previous example
   already: we placed / directly after the predicate.  This principle
   holds universally.

   E.g. if we want to make sure that we really get only the formal
   parameter nodes in the above example, we might say this:

   : (?subprogram && ! ?@declaration) / ?formal_parameter

   Knowing this, we might also rewrite this example as follows:

   : ?subprogram (! ?@declaration) / ?formal_parameter

   ... but that's perhaps less clear.

** $@ID — value of attribute DW_AT_ID

   This is the first example of a function that can produces something
   else than Dwarf DIE's.  This will yield whatever value the
   attribute has--a number, a string, a DIE, or a sequence.  E.g. we
   could obtain names of the formal parameters selected above:

   : (?subprogram && ! ?@declaration) / ?formal_parameter $@name

   The result would be a set of strings with names of all formal
   parameters in the program.  That's not very useful (yet), but
   there's another use of this same feature: for attributes with
   reference form, we get the effect of traversing over the edge
   rooted at given attribute.  For example, we could get formal
   parameter types thus:

   : (?subprogram && ! ?@declaration) / ?formal_parameter $@type

   ... which is a bit more useful.  We might use this to discover
   whether some formal parameters have structure types, and would
   therefore incur a potentially expensive copy when the subprogram is
   invoked:

   : (?subprogram && ! ?@declaration) / ?formal_parameter
   : $@type ?structure_type

   So that will let us know whether there are any offenders like that.
   But that's not what we need.  We would like to know about the
   subprograms themselves, that have this property!  Hence:

** if EXPR — sub-expression predicate

   This predicate holds for elements, for which EXPR produces at least
   a single value.  The input to EXPR is the same working set that is
   the input to the overall predicate, but EXPR itself is evaluated in
   what we call sub-expression context: what happens in EXPR, stays in
   EXPR, and we only care whether at least a single value comes out of
   there.

   With this, we can reformulate our query a bit:

   : (?subprogram && ! ?@declaration)
   : if (/ ?formal_parameter $@type ?structure_type)

   But this still shows only functions that take structure arguments
   directly.  But what if they take const arguments?  Or if they take
   a typedef that evaluates to a structure?  For these cases we need
   to keep peeling the fluff until we get to the interesting DIE's.
   Enter iterators:

** EXPR*, EXPR+, EXPR? — expression iteration

   - EXPR* leaves the working set unchanged, then adds to that the
     result of one application of EXPR, then of another, etc.  It
     works similarly to * in regular expressions.
   - EXPR+ is exactly like EXPR EXPR*.
   - EXPR? is like EXPR*, but applies at most once.

   We can use this tool to remove const_type, volatile_type and
   typedef layers from out potential structure:

   : (?subprogram && ! ?@declaration)
   : if (/ ?formal_parameter $@type
   :     ((?const_type || ?volatile_type || ?typedef) $@type)*
   :     ?structure_type)

   So this was a small sampler of the language.  In the next section,
   all of it will be introduced in a semi-formal, but rather terse
   format.


* Overview of dwgrep language

** EXPR → EXPR₁ EXPR₂ … — pipeline formation

   The constituent EXPR's may yield more than one output value.  A new
   working set is formed by gathering all these returned values.  If
   you wish to get an actual list of values instead, see below for {}
   operator, which captures the resulting values and wraps them in a
   sequence.

** EXPR → “(” EXPR₁ “)”

** EXPR → “{” EXPR₁ “}” | “{” “}” — sub-expression capture

   This takes all the values that EXPR₁ yields, and returns them in a
   single sequence.  So each working set element is converted into a
   list of values that EXPR₁ yielded.

   XXX doesn't this mean we'll get a whole bunch of empty lists in
   some contexts?

   - "{}" by itself is a notation of an empty list.

   : {/}    # list of immediate children
   : {/*}   # list of all descendants

** EXPR → EXPR₁ “*” | EXPR₁ “+” | EXPR₁ “?” — iteration

** EXPR → “$@”ID | “:@”ID — attribute access

   - $@ID yields a value of DW_AT_ID.  This can be a string, a number,
     a sequence, or another DIE.  In the latter case, $@ID is
     effectively a graph traversal.

   - :@ID yields DW_AT_ID itself, as an attribute object.  See below
     for property access to see what this can be used for.

** EXPR → “/” | “/parent” | “/next” | “/prev” — traversal

** EXPR → EXPR₁ “,” EXPR₂ … — fork

   Fork evaluates all constituent EXPR's with the same input.  In then
   yields all values that each EXPR yields.  Thus for each working set
   element on input, this may produce several elements on output--zero
   or more for each constituent expression.

   If you want to get actual sequences out of this, use operator {}.

   : {1, 2, 3}   # a list with three values, 1, 2 and 3.

** EXPR → PRED₁ — filtering

** EXPR → “->” ID | “$”ID — binding, recall

   The identifier together with current value is attached to a working
   set element.  This is where working set elements differ from
   values: a working set element contains a value _and_ a set of
   bindings.  The value inside the element may change, but the
   bindings stay intact.

   For purposes of pruning duplicate working set elements, attached
   bindings are considered as well.  It is thus possible to have the
   same value in the set in many copies, each with a different set of
   bindings attached.  In this sense, the bindings serve as contextual
   information for each value.

   - This can be used to emulate for loops, kind of:
     : {1, 2, 3, 4}->i {1, 2, 3, 4}->j ($i > $j) {$i, $j} mul
     ... this should return:
     : 2, 3, 4, 6, 8, 12

     Possibly imperative-style loops work as well:
     : 1 -> A ({$A, 1} add -> A)*
     That's fairly disgusting and I'm not entirely sure whether and
     how exactly it works.

   - XXX how do we unbind, forget a name?

** EXPR → “$_” — identity function

** EXPR → “$pos” — position of element in sequence or working set

   This is useful for picking values out of sequences.  We might
   consider a syntactic sugar for this:
   - EXPR → “[” EXPR₁ “]” — sugar for ($pos == (EXPR₁)) XXX
   - another possibility is to have PRED → “[” EXPR₁ “]” instead of
     current PRED → “if” “(” EXPR₁ “)”.

** EXPR → “add” | “sub” | “mul” | “div” | “mod” — math

   - We already use +, * and /, but math shouldn't be useful very
     often anyway, so it's done in this roundabout way.  Possibly use
     this for gt, ge, lt, le, eq, ne as well?

   - These are functions like any others.  They take whatever is on
     their input, and do math on it.  Note therefore that they behave
     as suffix operators.

   - Typically, input element would be a list.  If it isn't, it's as
     if it was a list containing that one element.  The following
     table summarizes the behavior of thees functions:

     |------------+----------+-------------|
     | input list | function | result      |
     |------------+----------+-------------|
     | {}         | add,sub  | 0           |
     | {}         | mul      | 1           |
     | {A}        | add,mul  | A           |
     | {A}        | sub      | -A          |
     | {A, B}     | any      | A op B      |
     | {A, B, C}  | any      | A op B op C |
     |------------+----------+-------------|

     Undefined operations simply produce no result.

** EXPR → “concat” — sequence processing

** EXPR → “"” (string literal) “"” | (“0x”|“0”|“”)[1-9][0-9]* — literals

   String literals allow expression interpolation:

   - %{ and %} enclose an EXPR that's evaluated as usual, and whose
     input is whatever is the input to the string literal itself.  The
     result is converted to a string and embedded in the string
     template.
   - %s stands for %{ $_ %}
   - %% stands for a single %

** EXPR → “:” ID — value property access

   - This yields various values according to the type of input
     element:

     |------+------------+---------------------------------------------|
     | type | key        | meaning                                     |
     |------+------------+---------------------------------------------|
     | DIE  | type       | string "DIE"                                |
     | DIE  | tag        | integer value of tag                        |
     | DIE  | children   | multivalue of DIE's.  Same as simply "/".   |
     | DIE  | attributes | multivalue of AT's                          |
     | DIE  | offset     | integer denoting offset of DIE in file      |
     | DIE  | @ID        | like :attributes ($_ == DW_AT_ID)           |
     |------+------------+---------------------------------------------|
     | AT   | type       | string "AT"                                 |
     | AT   | name       | integer value of attribute name             |
     | AT   | form       | integer value of form                       |
     | AT   | value      | attribute value (can be DIE, SEQ, INT, STR) |
     | AT   | offset     | integer denoting offset of AT in file       |
     |------+------------+---------------------------------------------|
     | SEQ  | type       | string "SEQ"                                |
     | SEQ  | length     | length of sequence                          |
     |------+------------+---------------------------------------------|
     | STR  | type       | string "STR"                                |
     | STR  | length     | length of string                            |
     |------+------------+---------------------------------------------|
     | INT  | type       | string "INT"                                |
     |------+------------+---------------------------------------------|

** EXPR → “;” — universe (XXX)

   Yields all nodes.  This operator is implicit at the beginning of
   the full dwgrep expression.

** PRED → “(” PRED₁ “)”

** PRED → “^” — root node predicate

   This is exactly equivalent to (! if /parent).

   Note that this is a predicate.  It is true on a root node, false
   otherwise.

   - (/parent* ^) -- finds a root node of current node
     - XXX possibly shorten this as "$^"?

** PRED → “?”ID — tag predicate

** PRED → “?@”ID — attribute presence predicate

** PRED → PRED₁ “&&” PRED₂ | PRED₁ “||” PRED₂ | “!” PRED₁ — logical connectives

** PRED → EXPR₁ “==” EXPR₂ | EXPR₁ “!=” EXPR₂ — equivalence

   EXPR₁ and EXPR₂ are evaluated in sub-expression context and act if
   they were in sub-expression capture.  XXX really?

** PRED → EXPR₁ “<” EXPR₂ | EXPR₁ “>” EXPR₂ | EXPR₁ “<=” EXPR₂ | EXPR₁ “>=” EXPR₂ — comparison

   EXPR₁ and EXPR₂ are evaluated in sub-expression context and act if
   they were in sub-expression capture.  XXX really?

** PRED → EXPR₁ “=~” EXPR₂ | EXPR₁ “!~” EXPR₂ — regex matching

   EXPR₁ is a string to be match by regular expression at EXPR₂.
   EXPR₁ and EXPR₂ are evaluated in sub-expression context and act if
   they were in sub-expression capture.  XXX really?

** PRED → “if” EXPR₁ — sub-expression predicate

   This is exactly equivalent to ({EXPR₁} != {}).

   : (! if /) # keep childless DIE's only

** PRED → “.show” | “.dump” — debugging

   Both predicates always succeed, and print elements that they are
   tested on.

   - .show shows only the value
   - .dump shows debugging information as well--fuller output,
     attached values, that sort of thing


* Representing non-.debug_info information

** @decl_file

   The value is represented as actual string including path.

** @stmt_list

   $@stmt_list yields a number of pseudo-DIE's of type
   line_table_entry.  Each has the following attributes: @address,
   @op_index, @file, @line, @column, @is_stmt, @basic_block,
   @end_sequence, @prologue_end, @epilogue_begin, @isa,
   @discriminator.

** @location

   $@location yields a number of pseudo-DIE's of type
   location_list_entry.  Each has the following attributes: @address,
   and @ops.

   $@ops yields a number of pseudo-DIE's of type location_list_op.
   Each has the following attributes: @atom (which contains opcode),
   and possibly @number or also @number2 (with operands).

   - XXX possibly a means of evaluating?

** ELF symbols

* Examples
** Josh Stone's nontrivial-parameters script

   : (?subprogram && ! ?@declaration
   :  && !($@decl_file =~ "^/usr/" && $@decl_file !~ "^/usr/src/debug")) -> A
   : / ?formal_parameter -> B
   : $@type ((const_type || volatile_type || typedef) $@type)*
   : (?structure_type || ?class_type)
   : {"%{ $A $@decl_file %}:%{ $A $@decl_line %}: note: in function ",
   :  "`%{ $A $@name }%', parameter `%{ $B $@name %}' type is not trivial"} concat

   - In XQuery, it is:

   : declare function local:cvPeeledType($root, $node) {
   :     let $T := $root//*[@id = $node/at_type] return
   :     if ($T/name() = "tag_const_type"
   :         or $T/name() = "tag_volatile_type"
   :         or $T/name() = "tag_typedef")
   :     then local:cvPeeledType($root, $T)
   :     else $T
   : };
   :
   : doc ("xxxxx.xml")//tag_subprogram/
   : (let $A := tag_formal_parameter
   :  let $T := local:cvPeeledType(/, $A)
   :  return if ($T/name() = "tag_structure_type")
   :         then concat ($A/../at_name/text(), ": type of parameter ",
   :                      $A/at_name/text(), " is not trivial.")
   : 	else ())

   - Or some Python wrapper thing?

   : import re
   : for val in (dwg.filt (has_tag ("subprogram") & ~has_at ("declaration")
   :                       & lambda e: (re.match ("^/usr/.*", e.at ("decl_file"))
   :                                    and not re.match ("^/usr/src/debug.*",
   :                                                      e.at ("decl_file"))))
   :             .bind ("A")
   :             .children .filt (has_tag ("formal_parameter"))
   :             .bind ("B")
   :             .at ("type") .iterate (has_tag ("const_type") | has_tag ("volatile_type")
   :                                   | has_tag ("typedef")] .at ("type"))
   :             .filt (has_tag ("structure_type") | has_tag ("class_type")):
   :     A = val.binding ("A")
   :     B = val.binding ("B")
   :     print "%s: %s: note: in function %s, parameter %s type is not trivial" \
   :         % (A.at ("decl_file"), A.at ("decl_line"), A.at ("name"), B.at ("name"))

** check_die_decl_call:

   : ( (?@decl_column && !?@decl_line) "%s has decl_column, but NOT decl_line"
   : , (?decl_line && !?@decl_file) "%s has decl_line, but NOT decl_file"
   : , (?@decl_file && !?@decl_line) "%s has decl_file, but NOT decl_line"
   : , (?call_column && !?call_line) "%s has call_column, but NOT call_line"
   : , (?call_line && !?call_file) "%s has call_line, but NOT call_file"
   : , (?call_file && !?call_line) "%s has call_file, but NOT call_line" )

** check_die_line_info:

   : (?subprogram || ?inline_subroutine || ?entry_point || ?lexical_block
   :  || ?label || ?with_stmt || ?try_block || ?catch_block) -> A
   : ($@entry_pc, $@low_pc, $@ranges) -> B
   : /parent* ^
   : ({$@stmt_list ($A == $@address)} == {})
   : "Address %{$B%} referenced from %{$A%} not found in line table."

** contains DW_OP_fbreg && ! @frame_base
   : (! ?@frame_base) if ($@location $@ops $@atom == DW_OP_fbreg)

** uses register based operators
   : if ($@location $@ops (($@atom >= DW_OP_reg0 && $@atom <= DW_OP_regx)
   :                       || $@atom == DW_OP_bregx))

** whether it uses a deref operator
   : if ($@location $@ops $@atom
   :     if (-> A {DW_OP_deref, DW_OP_xderef, DW_OP_deref_size,
   :               DW_OP_xderef_size, DW_OP_GNU_deref_type} $A == $_))

** contains DW_OP_call_frame_cfa && $@low_pc == 0
   : $@low_pc == 0 && if ($@location $@ops $@atom == DW_OP_call_frame_cfa)

** is an empty location expression
   : ! if $@location

** location expression ends with implicit_value or stack_value
   : if ($@location $@ops (({$pos, 1} add) == :length)
   :     ($@atom == DW_OP_implicit_value || $@atom == DW_OP_stack_value))

* Old work
== check_duplicate_DW_tag_variable

--> check for two full DW_TAG_variable DIEs with the same DW_AT_name
    value

//variable[@declaration]

== check_linkage_external_die.cc

(SHT_DYNSYM | SHT_SYMTAB)/*[@type==STT_OBJECT or @type==STT_FUNC][@name != ""]
