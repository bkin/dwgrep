-*-org-*-
* Introduction

  Dwgrep is a tool and an associated language for querying Dwarf
  graphs.  You can think of dwgrep expressions as instructions
  describing a path through a graph, with assertions about the type of
  nodes on the way.

  The paths that dwgrep expressions describe are rather abstract, and
  apart from Dwarf DIE's and Attributes, they include integers and
  strings, and sequences of any of these types.  There are also means
  of expressing sub-conditions, i.e. assertions that such and such
  node (or value) is acceptable if another expression can match (or
  can't match) a different path through the graph.

  In particular, a simple expression in dwgrep might look like this:

  : ?subprogram child ?formal_parameter @name

  Which (ignoring the initial colon that's part of meta-syntax) says:
  show me values of DW_AT_name of DW_TAG_formal_parameter nodes that
  are children of DW_TAG_subprogram nodes.  Reading forward, you get
  list of instructions to a matcher: accept all DW_TAG_subprogram's,
  look at its children, accept those that are DW_TAG_formal_parameter,
  take value of attribute DW_AT_name.

  Another example comes from dwarflint:

  : ?@decl_column !@decl_line

  ... which looks for DIE's that have DW_AT_decl_column, but don't
  have DW_AT_decl_line.

* Computation

  Conceptually, dwgrep expressions form a pipeline of functions.  The
  Dwarf graph under consideration flows through this pipeline,
  modified by each function of the overall expression, and whatever
  comes out of the other end is the result of the query.

  We call what flows through the dwgrep expression a /working set/.
  Initial working set contains all DIE's in a given Dwarf graph.  As
  the working set is transformed, its elements can be more than just
  DIE's--as mentioned, they can be also integers, strings, etc.

  Each function takes on input an element of the working set, and
  produces zero or more elements on the output.  Note that producing
  several elements is different from producing an element that holds a
  single value of type sequence.  When a function is applied on a
  working set element, the following can happen:

  - that element is removed (if a function doesn't yield anything)
  - the element is changed for another
  - that element is "forked", replaced with several elements

  When dwgrep expression is evaluated, the functions in the expression
  are applied to each element of the working set, and the output is
  collected to form a new working set.  The whole scheme is thus
  reminiscent of shell pipeline, except you have richer variety of
  types instead of lines.

  There is a subtle difference between values and elements: elements
  contain /stacks/ of values.  Functions in the pipeline manipulate
  these stacks.  If an element is removed from a working set, that
  means that the computation stopped making sense: some assertion
  didn't hold, or an attribute was expected that was not available.
  Such computations are discarded.  On the contrary, a function can
  produce several stacks, which means that several possible paths
  forward exist.  The values on stack provide a context to the result.


* Introduction to the dwgrep language

  In following, examples are generally written as follows:

  : blah blah lorem ipsum stuff

  The initial colon is not part of the example, but an artifact of
  Emacs org mode.

** ?ID — DIE tag assertion

   The assertion "?ID" takes the value at top of stack (TOS).  If what
   is there is not a DIE, or it's a DIE whose tag is not DW_TAG_ID,
   this function yields nothing.  Otherwise it yields the input stack
   unchanged.

   For example, to list all subprograms, one would use the following
   expression:

   : ?subprogram

** ?@ID, !@ID — Attribute presence/absence assertion
** EXPR₁ EXPR₂ … — concatenation

   "?@ID" holds if TOS is a DIE with DW_AT_ID.

   In dwgrep, function pipelines are formed by simply placing
   functions next to each other.  The stacks that the left function
   produces becomes an input of the right function.  For assertions,
   this happens to work as a logical and.

   For example, this is how we can get a list of all subprograms that
   are pure declarations:

   : ?subprogram ?@declaration

   Similarly, to get subprograms that are _not_ pure declarations, we
   say:

   : ?subprogram !@declaration

** child — child traversal

   This function drops the DIE at TOS, and produces a set of stacks,
   each with one child pushed to TOS.  If applied on a childless DIE
   or on a value that's not a DIE at all, it produces nothing, and
   such computations are thus dropped.  To get at the formal arguments
   of the subprograms from the previous example, one might say:

   : ?subprogram !@declaration child

   If we want to make sure these children are actually formal
   parameters:

   : ?subprogram !@declaration child ?formal_parameter

** @ID — value of attribute DW_AT_ID

   This is the first example of a function that can produces something
   else than Dwarf DIE's.  This will replace the DIE at TOS with a
   value of the attribute of that DIE.  E.g. we could obtain names of
   the formal parameters selected above:

   : ?subprogram !@declaration child ?formal_parameter @name

   The result would be a set of strings with names of all formal
   parameters in the program.  That's not very useful, as that just
   lists a bunch of names.

   But there's another use of this same feature: for attributes with
   reference form, we get the effect of traversing over the edge
   rooted at given attribute.  For example, we could get types of
   formal parameters thus:

   : ?subprogram !@declaration child ?formal_parameter @type

   ... which is a bit more useful.  We might use this to discover
   whether some formal parameters have structure types, and would
   therefore incur a potentially expensive copy when the subprogram is
   invoked:

   : ?subprogram !@declaration child ?formal_parameter @type ?structure_type

   So that will let us know whether there are any offenders like that.
   That's closer to being interesting, but not quite what we need
   either.  We would like to know about the subprograms themselves,
   that have this property!  Hence:

** ?{EXPR}, !{EXPR} — Sub-expression assertions

   Some dwgrep expressions are evaluated in what we call a
   sub-expression context.  What happens in sub-expression context,
   stays there--the stack effects of sub-expression computation never
   leak back to working set.

   The ?{} expression is one such case.  It asserts that EXPR produces
   at least one element.  We can use it to get to DIE's that have
   arguments that are structures:

   : ?subprogram !@declaration ?{child ?formal_parameter @type ?structure_type}

   This asks whether, after going to types of children that are formal
   parameters, we get a structure.  Because the initial two assertions
   have no stack effects anyway, we might say the same thing thus:

   : ?{?subprogram !@declaration child ?formal_parameter @type ?structure_type}

   The other sub-expression assertion, !{}, holds if EXPR produces no
   values at all.  We don't need that, but we could use it to reword
   the query thus:

   : ?subprogram !{?@declaration}
   : ?{child ?formal_parameter @type ?structure_type}

   If a DIE is a pure declaration, the expression ?@declaration yields
   unchanged incoming stack.  But !{} only holds for expressions that
   yield nothing at all, thus such DIE's are rejected.

   But there's more than DW_TAG_structure_type, we care about
   DW_TAG_class_type as well!  We can express "and" easily simply by
   juxtaposing the assertions, but we would like a way of expressing
   "or" as well!

** EXPR, EXPR — alternative paths

   This expression evaluates all constituent EXPR's with the same
   input, and then yields all values that each EXPR yields.  If the
   expressions are assertions, this happens to behave exactly like a
   logical or.  So:

   : ?subprogram !@declaration
   : ?{child ?formal_parameter @type (?structure_type, ?class_type)}

   So this is fine, but it still shows only functions that take
   structure (or class) arguments directly.  But what if they take a
   const argument?  Or if they take a typedef that evaluates to a
   structure?  For these cases we need to keep peeling the fluff until
   we get to the interesting DIE's.  Enter iterators:

** EXPR*, EXPR+, EXPR? — expression iteration

   - EXPR* leaves the working set unchanged, then adds to that the
     result of one application of EXPR, then of another, etc.  It
     works similarly to * in regular expressions.
   - EXPR+ is exactly like EXPR EXPR*.
   - EXPR? is like EXPR*, but applies at most once.

   We can use this tool to remove const_type, volatile_type and
   typedef layers from our potential structure:

   : ?subprogram !@declaration
   : ?{child ?formal_parameter
   :   @type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type)}

   So this was a small sampler of the language.  In the following
   sections, all of it will be introduced in a semi-formal, but rather
   terse format.

* Stack maintenance

  A stack of values is maintained for each computation context (in
  fact the stack is that context).  Various expressions treat the
  stack in various ways.  In particular

  - initially the stack is composed of a single value of type DIE

  - stack manipulation words are used for explicit reordering of stack
    elements:

    |------+---------+-----------|
    | op   | before  | after     |
    |------+---------+-----------|
    | dup  | A B C D | A B C D D |
    | over | A B C D | A B C D C |
    | swap | A B C D | A B D C   |
    | rot  | A B C D | A C D B   |
    | drop | A B C D | A B C     |
    |------+---------+-----------|

    Realistically, most of what end users should write will be an
    occasional dup, possibly a swap.  Drop shouldn't be needed (that's
    what sub-expressions are for), and the deep stack manipulation
    should be unnecessary as well.

  - literals push a new value on stack
    - integers (1, 0x20, -7)
    - strings ("Ahoj!")
    - sequences ([1, 2, 3])

  - assertions inspect TOS (or several values on TOS), test the
    condition, and either leave the stack unchanged, or abort the
    computation.  They do not pop.  This includes ?@at, !@at, ?tag,
    !tag, ?{}, !{}, all{}, eq, ne, gt, match, etc.

  - all other forms pop top elements of the stack, and replace with
    produced values.  This includes traversal forms (@at, .@at, child,
    parent, etc.) and operators (sub, add, etc.).

  Stacks have limited capacity.  XXX my current thinking is to have a
  default limit of 4 slots, and allow to increase it via a command
  line argument.  This limit should make sure that unbounded
  computation is quickly detected.  Stack overflow is a hard error,
  and results in abort of dwgrep itself--the offending computation is
  not silently discarded.

  Deep(er) stacks may be useful for deeply embedded ?{} and !{} forms,
  but are unlikely to be useful directly, as there are no stack
  manipulation words to get at the levels beyond top three items.


* Overview of dwgrep language

** Core operators

*** EXPR → EXPR₁ EXPR₂ — concatenation

    The constituent EXPR's may yield more than one output value.  A new
    working set is formed by gathering all these returned values.  If
    you wish to get an actual list of values instead, see below for []
    operator, which captures the resulting values and wraps them in a
    sequence.

*** EXPR → “(” EXPR₁ “)” — grouping, precedence

*** EXPR → “swap” | “dup” | “over” | “rot” | “drop” — stack shuffling

*** EXPR → “[” EXPR₁ “]” | “[” “]” — sub-expression capture

    This is a literal form that gathers what EXPR₁ yields and pushes a
    sequence with those elements.  It can be used for constructing a
    sequence literal:

    : [1, 2, 3]        # produces a list with elements 1, 2 and 3
    : [child]          # list of immediate children
    : [child*]         # list of all descendants

    [] is a literal that produces an empty list.  It is exactly
    equivalent to (among others):
    : [ 0 1 eq ]

*** EXPR → “each” — pop a list, yield all its elements
*** EXPR → “.”ID — value property access

    - This yields various values according to the type of input
      element:

      |------+------------+--------------------------------------------------|
      | type | ID         | meaning                                          |
      |------+------------+--------------------------------------------------|
      | any  | rank       | rank of element within producing expression      |
      |------+------------+--------------------------------------------------|
      | DIE  | type       | string "DIE"                                     |
      | DIE  | tag        | integer value of tag                             |
      | DIE  | children   | yields children of DIE.  Same as simply "child". |
      | DIE  | attributes | yields all Attribute objects of DIE              |
      | DIE  | offset     | integer denoting offset of DIE in file           |
      | DIE  | @ID        | like .attributes DW_AT_ID eq                     |
      |------+------------+--------------------------------------------------|
      | AT   | type       | string "AT"                                      |
      | AT   | name       | integer value of attribute name                  |
      | AT   | form       | integer value of form                            |
      | AT   | value      | attribute value (can be DIE, SEQ, INT, STR)      |
      | AT   | offset     | integer denoting offset of AT in file            |
      |------+------------+--------------------------------------------------|
      | SEQ  | type       | string "SEQ"                                     |
      | SEQ  | length     | length of sequence                               |
      |------+------------+--------------------------------------------------|
      | STR  | type       | string "STR"                                     |
      | STR  | length     | length of string                                 |
      |------+------------+--------------------------------------------------|
      | INT  | type       | string "INT"                                     |
      |------+------------+--------------------------------------------------|

    - XXX it seems like these should be simply words.  Why use
      .children instead of child?  Why use .attributes instead of
      attribute?  (Which should exist.)  Similarly for type, tag,
      offset, value, name, etc.  "name" might actually be "tag".

*** EXPR → EXPR₁ “*” | EXPR₁ “+” | EXPR₁ “?” — iteration
*** EXPR → EXPR₁ “,” EXPR₂ … — alternate

    EXPR yields all the values that EXPR₁ and EXPR₂ yield.  In practice
    this can be used as logical or, or to construct literal lists.

*** EXPR → “add” | “sub” | “mul” | “div” | “mod” — arithmetic

    - Two elements are popped: A and B, with B the original TOS, and "A
      op B" is pushed again.

    - Undefined operations (such as division by zero) simply abort the
      computation in question.

    - XXX how to sum a list?

*** EXPR → “eq” | “ne” | “gt” | “ge” | “lt” | “le” — comparison assertions

    - Two elements are inspected: TOS and one below that (B and A,
      respectively).  The assertion holds if A op B is true.  Comparing
      values of different types is not defined, and such assertions
      fail as well.

*** EXPR → “match” — regex assertion

    This produces nothing when applied to non-string values.  Use "%s"
    to convert other value types to string.

    This is similar to "eq", except asserts that TOS (which is a string
    with a regular expression) matches the value below TOS.

*** EXPR → “concat” — concatenate lists or strings
*** EXPR → “"” (string literal) “"” | (“0x”|“0”|“”)[1-9][0-9]* — literals

    String literals allow expression interpolation:

    - %( and %) enclose an EXPR that's evaluated in plain context, and
      whose input is whatever is the input to the string literal
      itself.  TOS is then popped, converted to a string and embedded
      in the string template.

    - %{ EXPR %} is like %( EXPR %), but it's evaluated in
      sub-expression context.  TOS of resulting stack is still
      inspected for value to interpolate.

    - %s stands for %( %)

    - %% stands for a single %

    The resulting string is pushed to stack after all interpolations
    are processed one after another.

*** EXPR → “\dump” — debug assertion

    Always succeeds, but as a side effect prints some information about
    the computation in whose context it appeared.

*** EXPR → XXX universe

    Should produce all DIE's of Dwarf file again.  This operator is
    implicit at the beginning of the full dwgrep expression.


** Derived operators

   (Note that the fact that these operators can be derived from above,
   or from one another, doesn't mean they actually are.)

*** EXPR → “?”ID | “!”ID — DIE tag assertion

    - ?ID is exactly equivalent to:
      : ?{.tag DW_TAG_ID eq}
    - !ID is exactly equivalent to:
      : ?{.tag DW_TAG_ID ne}
    - Note that either form fails when applied to a non-DIE value.

*** EXPR → “?@”ID | “!@”ID — attribute presence/absence assertions

    - Apart from asserting attribute presence explicitly, one can
      simply access the attribute value.  If an attribute like that is
      not available at all, computation is aborted.

    - Attributes with forms DW_FORM_flag are handled specially.  If
      such attribute is present, but it has a value of false (0), it is
      treated as if it were absent.  Similarly when asserting absence
      of attribute with such form: if it has a value of 0, absence is
      asserted even though the attribute is present.

    - ?@at is exactly equivalent to:
      : ?{.@at (?{!{.form DW_FORM_flag ne}, ?{.value 0 ne}})}

    - !@at is exactly equivalent to:
      : ?{!{.@at}, .@at ?{.form DW_FORM_flag eq} ?{.value 0 eq}}

*** EXPR → “.@”ID | “@”ID | “/@”ID — attribute access

    - .@ID is a traversal form that produces a single value of type
      Attribute (if the DIE on TOS has that attribute).  It is exactly
      equivalent to:
      : .attributes ?{.name DW_AT_ID eq}

    - @ID is exactly equivalent to:
      : .@ID .value

    - /@ID is equivalent to:
      : .@ID {.form (DW_FORM_ref1, DW_FORM_ref2, …) eq} @ID
      I.e. it's a value access that asserts that the value is an edge
      in Dwarf graph.

*** EXPR → “child” | “parent” | “next” | “prev” — DIE tree traversal

    These traversal forms replace a DIE on TOS with, respectively, its
    child DIE(s), its parent DIE, next sibling, and previous sibling.

    - child is exactly equivalent to:
      : .children

    - parent is exactly equivalent to (XXX $universe):
      : $universe ?{child eq} swap drop

    - next is exactly equivalent to:
      : dup parent child eq swap drop
      : .rank 1 add swap parent child ?{.rank rot eq} swap drop
      The first line is necessary to make sure that .rank later refers
      to order in children array, not to e.g. a result of ([XYZ] each).

    - prev can be defined in manner similar to next.

*** EXPR → “?{” EXPR₁ “}” | “!{” EXPR₁ “}” — sub-expression assertions

    - ?{ EXPR₁ } is exactly equivalent to:
      : [ EXPR₁ ] [] ne
    - !{ EXPR₁ } is exactly equivalent to:
      : [ EXPR₁ ] [] eq

    - Examples:
      : !{child}       # keep leaf DIE's only

*** EXPR → “each2” — deep each

    - each2 is exactly equivalent to:
      : each swap each ?{.rank swap drop over .rank eq} swap

      So it takes two lists from the stack, and produces stacks that
      have those two elements replaced with individual elements from
      those lists that correspond to each other.  For example:
      : A B [C₁, C₂, C₃] [D₁, D₂, D₃]

      ... would be replaced with three stacks:
      : (A B C₁ D₁, A B C₂ D₂, A B C₃ D₃)

    - we could also have each3 with the meaning of:
      : each2 rot each ?{over .rank swap drop .rank eq} rot rot

*** EXPR → “all{” EXPR₁ “}” — universal quantifier

    - This is exactly equivalent to:
      : ?{[each {EXPR₁}] .length swap .length eq}

    - I.e. it expects a list on TOS.  This list is forked into
      individual computations by "each".  Only if each of these
      computations yields a value does the overall predicate succeed.
      The list on TOS is kept.

*** EXPR → “first” | “second” | “third” | “last” — rank assertion

    Assertion on rank of tested element within expression that
    generated it.  If an expression generates elements X, Y, and Z on
    top of existing stack A B C, three stacks come out: A B C X, A B C
    Y, and A B C Z.  "first" would be true in context of A B C X, etc.

    To get a given element when a list is on TOS, one would do e.g.
    : each last

    - first is exactly equivalent to:
      : ?{.rank 0 eq}
      (and similarly for second, third, ...)

    - last is exactly equivalent to:
      : ?{.length 1 sub swap .rank rot eq}

*** EXPR → “^” — root node assertion

    - Exactly equivalent to:
      : !{parent}
    - Examples:
      : parent* ^        # finds a root node of node on TOS


* Representing non-DIE information

** @decl_file

   The value is represented as actual string including path.

** @stmt_list

   @stmt_list yields a number of pseudo-DIE's of type
   line_table_entry.  Each has the following attributes: @address,
   @op_index, @file, @line, @column, @is_stmt, @basic_block,
   @end_sequence, @prologue_end, @epilogue_begin, @isa,
   @discriminator.

** @location

   @location yields a number of pseudo-DIE's of type
   location_list_entry.  Each has the following attributes: @address,
   and @ops.

   @ops yields a number of pseudo-DIE's of type location_list_op.
   Each has the following attributes: @atom (which contains opcode),
   and possibly @number or also @number2 (with operands).

   - XXX possibly a means of evaluating?

** XXX ELF symbols
** XXX Dwarf CU version -- an artificial attribute?
   - https://stackoverflow.com/questions/16169864
** XXX abbreviation section?  (libdw doesn't have interfaces for this)
   - note that one can look for attribute form by saying :@at :form
   - would a link from a DIE to its abbreviation be useful?
** XXX integrating aadr2line
   - low_pc and high_pc should be convertible to symbol name on
     request (possibly manually by cross-matching with ELF symtabs).
** XXX .debug_frame, .eh_frame
   - do we need an overarching "theory" for both of these
   - also, there's fair amount of tables around here.  Does it make
     sense to understand them as first-class citizen of some sort?
     Currently we understand there are values, every value has some
     properties, and some values have attributes.
** XXX .debug_macro

* Examples
** Josh Stone's nontrivial-parameters script

   - stack machine

   : ?subprogram !@declaration
   : {@decl_file {"^/usr/" match} !{"^/usr/src/debug" match}}
   : dup child ?formal_parameter
   : {@type ((?const_type, ?volatile_type, ?typedef) @type)*
   :  (?structure_type, ?class_type)} swap
   : "%{ @decl_file %}: %{ @decl_line %}: note: in function \
   : `%( @name %)', parameter `%{ @name %}' type is not trivial"

   : ?formal_parameter
   : {@type ((?const_type, ?volatile_type, ?typedef) @type)*
   :  (?structure_type, ?class_type)}
   : dup parent ?subprogram !@declaration
   : {@decl_file {"^/usr/" match} !{"^/usr/src/debug" match}}
   : "%{ @decl_file %}: %{ @decl_line %}: note: in function \
   : `%( @name %)', parameter `%{ @name %}' type is not trivial"

   - In XQuery, it is:

   : declare function local:cvPeeledType($root, $node) {
   :     let $T := $root//*[@id = $node/at_type] return
   :     if ($T/name() = "tag_const_type"
   :         or $T/name() = "tag_volatile_type"
   :         or $T/name() = "tag_typedef")
   :     then local:cvPeeledType($root, $T)
   :     else $T
   : };
   :
   : doc ("xxxxx.xml")//tag_subprogram/
   : (let $A := tag_formal_parameter
   :  let $T := local:cvPeeledType(/, $A)
   :  return if ($T/name() = "tag_structure_type")
   :         then concat ($A/../at_name/text(), ": type of parameter ",
   :                      $A/at_name/text(), " is not trivial.")
   : 	else ())

   - Or some Python wrapper thing?

   : import re
   : for val in (dwg.filt (has_tag ("subprogram") & ~has_at ("declaration")
   :                       & lambda e: (re.match ("^/usr/.*", e.at ("decl_file"))
   :                                    and not re.match ("^/usr/src/debug.*",
   :                                                      e.at ("decl_file"))))
   :             .bind ("A")
   :             .children .filt (has_tag ("formal_parameter"))
   :             .bind ("B")
   :             .at ("type") .iterate (has_tag ("const_type") | has_tag ("volatile_type")
   :                                   | has_tag ("typedef")] .at ("type"))
   :             .filt (has_tag ("structure_type") | has_tag ("class_type")):
   :     A = val.binding ("A")
   :     B = val.binding ("B")
   :     print "%s: %s: note: in function %s, parameter %s type is not trivial" \
   :         % (A.at ("decl_file"), A.at ("decl_line"), A.at ("name"), B.at ("name"))

** check_die_decl_call:

   : ( ?@decl_column !@decl_line "%s has decl_column, but NOT decl_line"
   : , etc.)

** check_die_line_info:

   : dup (?subprogram, ?inline_subroutine, ?entry_point, ?lexical_block,
   :      ?label, ?with_stmt, ?try_block, ?catch_block)
   : (@entry_pc, @low_pc, @ranges)
   : swap parent* ^
   : !{@stmt_list @address eq} swap
   : "Address %s referenced from %s not found in line table."

** contains DW_OP_fbreg && ! @frame_base

   : !@frame_base ?{@location @ops @atom DW_OP_fbreg eq}

** uses register based operators

   : ?{@location @ops @atom (DW_OP_bregx eq, ?{DW_OP_reg0 ge} ?{DW_OP_regx le})}

** whether it uses a deref operator

   : ?{dup @location @ops @atom (DW_OP_deref, DW_OP_xderef, DW_OP_deref_size,
   :                             DW_OP_xderef_size, DW_OP_GNU_deref_type) eq}

** contains DW_OP_call_frame_cfa && $@low_pc == 0

   : ?{@low_pc 0 eq} ?{dup @location @ops @atom DW_OP_call_frame_cfa eq}

** is an empty location expression

   : ?@location !{@location}

** location expression ends with implicit_value or stack_value

   : ?{dup @location @ops last @atom (DW_OP_implicit_value, DW_OP_stack_value) eq}

** types inconsistent between instance and specification
   - http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43053

   : ?subprogram dup @specification child ?formal_parameter
   : swap child ?formal_parameter
   : {.pos swap .pos eq} {@type swap @type ne}

   XXX could improve using each2

** duplicat DW_TAG_const_type
   - http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56740

   : (?const_type, ?volatile_type, ?restrict_type)
   : dup parent* child* (?const_type, ?volatile_type, ?restrict_type)
   : {.offset swap .offset ne} {.tag swap .tag eq} {@type swap @type eq}

   XXX if we had scoping instead of dup/drop, would that be better?

   : (?const_type, ?volatile_type, ?restrict_type);
   : parent* child* (?cons_type, ?volatile_type, ?restrict_type)
   : {<.offset, .offset> ne} {<.tag, .tag> eq} {<@type, @type> eq}

   XXX <> for vertical arrays?

*** EXPR → “<” EXPR₁ “,” EXPR₂ … “>” — stack transformation

    This would apply EXPR₁ with TOS, EXPR₂ with one below TOS, etc.
    It then gathers TOS's of these transformed The result would be a
    transformed stack.

    Or maybe EXPR → “<” NUM “>”, which XXX

** find any attribute with value "blah"

   : ?{.attributes ?{.form (DW_FORM_string, DW_FORM_strp) eq} .value "blah" eq}

   - very likely even simply:
   : ?{.attributes .value "blah" eq}


* Old work
== check_duplicate_DW_tag_variable

--> check for two full DW_TAG_variable DIEs with the same DW_AT_name
    value

//variable[@declaration]

== check_linkage_external_die.cc

(SHT_DYNSYM | SHT_SYMTAB)/*[@type==STT_OBJECT or @type==STT_FUNC][@name != ""]
