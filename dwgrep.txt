-*-org-*-
* Computation

  Dwgrep is tool and an associated language for expressing queries
  done on a Dwarf graph.  Conceptually expressions of this language
  form a pipeline of functions.  The Dwarf graph under consideration
  flows through this pipeline, modified by each function of the
  overall expression, and whatever comes out of the other end is the
  result of the query.

  We call what flows through the dwgrep expression a /working set/.
  The elements of this set can by any of the following:

  - Dwarf DIE's
  - integers, strings
  - sequences of other values

  Initial working set contains all DIE's in a given Dwarf graph (and
  then some).

  Each function takes a working set element on input, and produces
  zero or more elements on the output.  The functions are applied to
  each element of the working set, and the output is collected to form
  a new working set.  So functions work as generalized filters that
  drop, change, or add new elements to working set.

  Functions in dwgrep expressions generally come in one of the
  following flavors:

  - predicates (keep elements for which the predicate holds, drop
    others)
  - traversals (replace one DIE with another (or a set thereof))
  - producers (replace Dwarf DIE's with values of other types)

  In following, examples are generally written as follows:

  : blah blah lorem ipsum stuff

  The initial colon is not part of the example, but an artifact of
  Emacs org mode.


* Introduction to the dwgrep language

** ?ID — Filtering DIE's by tag

   The predicate "?ID" holds for DIE's whose tag is DW_TAG_ID.  For
   example, to list all subprograms, one would use the following
   expression:

   : ?subprogram

** ?@ID — Filtering DIE's by attribute
** PRED₁ && PRED₂, PRED₁ || PRED₂, !PRED — the usual logical connectives

   "?@ID" is a predicate that holds for DIE's with an attribute
   DW_AT_ID.  To list all subprograms that are not pure declarations,
   one would use the following expression:

   : ?subprogram && ! ?@declaration

** (EXPR) — we can parenthesize for clarity or precedence
** / — child traversal

   Function "/" replaces every DIE with all its children.  Childless
   DIE's are thus dropped.  To get at the formal arguments of the
   subprograms from the previous example, one might say:

   : (?subprogram && ! ?@declaration) /

** EXPR₁ EXPR₂ … — pipeline formation

   In dwgrep, pipelines are formed by simply placing each function
   next to each other.  This can be seen in the previous example
   already: we placed / directly after the predicate.  This principle
   holds universally.

   E.g. if we want to make sure that we really get only the formal
   parameter nodes in the above example, we might say this:

   : (?subprogram && ! ?@declaration) / ?formal_parameter

   Knowing this, we might also rewrite this example as follows:

   : ?subprogram (! ?@declaration) / ?formal_parameter

   ... but that's perhaps less clear.

** $@ID — value of attribute DW_AT_ID

   This is the firet example of a function that can produces something
   else than Dwarf DIE's.  This will yield whatever value the
   attribute has--a number, a string, a DIE, or a sequence.  E.g. we
   could obtain names of the formal parameters selected above:

   : (?subprogram && ! ?@declaration) / ?formal_parameter $@name

   The result would be a set of strings with names of all formal
   parameters in the program.  That's not very useful (yet), but
   there's another use of this same feature: for attributes with
   reference form, we get the effect of traversing over the edge
   rooted at given attribute.  For example, we could get formal
   parameter types thus:

   : (?subprogram && ! ?@declaration) / ?formal_parameter $@type

   ... which is a bit more useful.  We might use this to discover
   whether some formal parameters have structure types, and would
   therefore incur a potentially expensive copy when the subprogram is
   invoked:

   : (?subprogram && ! ?@declaration) / ?formal_parameter
   : $@type ?structure_type

   So that will let us know whether there are any offenders like that.
   But that's not very useful--we want to know the exact context where
   this happens!  Hence:

** -> ID — name binding

   This can be used to remember a value, before further functions
   transform it.  The binding is remembered and carried along with a
   value, and survives value transformations unchanged.  Later on we
   can recall the value by saying:

** $ID — value recall

   This is again a function, but a degenerate one: it replaces any
   input argument with the previously-remembered value.

   We can use binding and recall together to get names of the
   functions with formal parameters of structure types:

   : (?subprogram && ! ?@declaration) -> A / ?formal_parameter
   : $@type ?structure_type $A $@name

   So that's more useful.

   But this still shows only functions that take structure arguments
   directly.  But what if they take const arguments?  Or if they take
   a typedef that evaluates to a structure?  For these cases we need
   to keep peeling the fluff until we get to the interesting DIE's.
   Enter iterators:

** EXPR*, EXPR+, EXPR? — expression iteration

   - EXPR* leaves the input set unchanged, then adds to that the
     result of one application of EXPR, then of another, etc.  It
     works similarly to * in regular expressions.
   - EXPR+ is exactly like EXPR EXPR*.
   - EXPR? is like EXPR*, but applies at most once.

   We can use this tool to remove const_type, volatile_type and
   typedef layers from out potential structure:

   : (?subprogram && ! ?@declaration) -> A / ?formal_parameter
   : $@type ((?const_type || ?volatile_type || ?typedef) $@type)*
   : ?structure_type $A $@name

   So this was a small sampler of the language.  In the next section,
   all of it will be introduced in a semi-formal, but rather terse
   format.


* Overview of dwgrep language

** EXPR → EXPR₁ EXPR₂ … — pipeline formation

   The constituent EXPR's may yield more than one output value.  A new
   working set is formed by gathering all these returned values.  If
   you wish to get an actual list of values instead, see below for {}
   operator, which captures the resulting values and wraps them in a
   sequence.

** EXPR → “(” EXPR₁ “)”

** EXPR → “{” EXPR₁ “}” | “{” “}” — subexpression capture

   This takes all the values that EXPR₁ yields, and returns them in a
   single sequence.  So each working set element is converted into a
   list of values that EXPR₁ yielded.

   XXX doesn't this mean we'll get a whole bunch of empty lists in
   some contexts?

   - "{}" by itself is a notation of an empty list.

   : {/}    # list of immediate children
   : {/*}   # list of all descendants

** EXPR → EXPR₁ “*” | EXPR₁ “+” | EXPR₁ “?” — iteration

** EXPR → “$@”ID | “:@”ID — attribute access

   - $@ID yields a value of DW_AT_ID.  This can be a string, a number,
     a sequence, or another DIE.  In the latter case, $@ID is
     effectively a graph traversal.

   - :@ID yields DW_AT_ID itself, as an attribute object.  See below
     for property access to see what this can be used for.

** EXPR → “/” | “/parent” | “/next” | “/prev” — traversal

** EXPR → EXPR₁ “,” EXPR₂ … — fork

   Fork evaluates all constituent EXPR's with the same input.  In then
   yields all values that each EXPR yields.  Thus for each working set
   element on input, this may produce several elements on output--zero
   or more for each constituent expression.

   If you want to get actual sequences out of this, use operator {}.

   : {1, 2, 3}   # a list with three values, 1, 2 and 3.

** EXPR → PRED₁ — filtering

** EXPR → “->” ID | “$”ID — binding, recall

   The identifier together with current value is attached to a working
   set element.  When a value of the element is replaced with another
   one, the attached bindings are left intact.  For purposes of
   pruning duplicate working set elements, attached bindings are
   considered as well.  They thus serve as contextual information for
   each value.

   - This can be used to emulate for loops, kind of:
     : {1, 2, 3, 4}->i {1, 2, 3, 4}->j ($i > $j) {$i, $j} mul
     ... this should return:
     : 2, 3, 4, 6, 8, 12

     Possibly imperative-style loops work as well:
     : 1 -> A ({$A, 1} add -> A)*
     That's fairly disgusting and I'm not entirely sure whether and
     how exactly it works.

   - XXX how do we unbind, forget a name?

** EXPR → “$_” — identity function

** EXPR → “$pos” — position of element in sequence or working set

   This is useful for picking values out of sequences.  We might
   consider a syntactic sugar for this:
   - EXPR → “[” EXPR₁ “]” — sugar for ($pos == (EXPR₁))???
   - another possibility is to have PRED → “[” EXPR₁ “]” instead of
     current PRED → “if” “(” EXPR₁ “)”.

** EXPR → “add” | “sub” | “mul” | “div” | “mod” — math

   - We already use +, * and /, but math shouldn't be useful very
     often anyway, so it's done in this roundabout way.  Possibly use
     this for gt, ge, lt, le, eq, ne as well?

   - These are functions like any others.  They take whatever's on
     their input, and do math on it.  Note therefore that they behave
     as suffix operators.

   - Typically, input element would be a list.  If it isn't, it's as
     if it was a list containing that one element.  The following
     table summarizes the behavior of thees functions:

     |------------+----------+-------------|
     | input list | function | result      |
     |------------+----------+-------------|
     | {}         | add,sub  | 0           |
     | {}         | mul      | 1           |
     | {A}        | add,mul  | A           |
     | {A}        | sub      | -A          |
     | {A, B}     | any      | A op B      |
     | {A, B, C}  | any      | A op B op C |
     |------------+----------+-------------|

     Undefined operations simply produce no result.

** EXPR → “concat” EXPR₁ — sequence processing

** EXPR → “"” (string literal) “"” | (“0x”|“0”|“”)[1-9][0-9]* — literals

   String literals allow expression interpolation:

   - %{ and %} enclose an EXPR that's evaluated as usual, and whose
     input is whatever's the input to the string literal itself.  The
     result is converted to a string and embedded in the string
     template.
   - %s stands for %{ $_ %}
   - %% stands for a single %

** EXPR → “:” ID — value property access

   - This yields various values according to the type of input
     element:

     |------+------------+---------------------------------------------|
     | type | key        | meaning                                     |
     |------+------------+---------------------------------------------|
     | DIE  | type       | string "DIE"                                |
     | DIE  | tag        | integer value of tag                        |
     | DIE  | children   | sequence of DIE's.  Same as simply "/".     |
     | DIE  | attributes | sequence of AT's                            |
     | DIE  | offset     | integer denoting offset of DIE in file      |
     | DIE  | @ID        | like :attributes ($_ == DW_AT_ID)           |
     |------+------------+---------------------------------------------|
     | AT   | type       | string "AT"                                 |
     | AT   | name       | integer value of attribute name             |
     | AT   | form       | integer value of form                       |
     | AT   | value      | attribute value (can be DIE, SEQ, INT, STR) |
     | AT   | offset     | integer denoting offset of AT in file       |
     |------+------------+---------------------------------------------|
     | SEQ  | type       | string "SEQ"                                |
     | SEQ  | length     | length of sequence                          |
     |------+------------+---------------------------------------------|
     | STR  | type       | string "STR"                                |
     | STR  | length     | length of string                            |
     |------+------------+---------------------------------------------|
     | INT  | type       | string "INT"                                |
     |------+------------+---------------------------------------------|

** PRED → “(” PRED₁ “)”

** PRED → “^” — root node predicate

   Note that this is a predicate.  It is true on a root node, false
   otherwise.

   - (/parent* ^) -- finds a root node of current node
     - XXX possibly shorten this as "$^"?
   - XXX how about "universe"--set of all nodes?  Do we need to encode
     this as (/parent* ^ /*)?  That wouldn't yield everything anyway
     (it would expand to all DIE's in CU's of which we have at least
     one node.  It would also not include non-.debug_info nodes.)

** PRED → “?”ID — tag predicate

** PRED → “?@”ID — attribute presence predicate

** PRED → PRED₁ “&&” PRED₂ | PRED₁ “||” PRED₂ | “!” PRED₁ — logical connectives

** PRED → EXPR₁ “==” EXPR₂ | EXPR₁ “!=” EXPR₂ — equivalence

   EXPR₁ and EXPR₂ are evaluated in subexpression context and act if
   they were in subexpression capture.  XXX really?

** PRED → EXPR₁ “<” EXPR₂ | EXPR₁ “>” EXPR₂ | EXPR₁ “<=” EXPR₂ | EXPR₁ “>=” EXPR₂ — comparison

   EXPR₁ and EXPR₂ are evaluated in subexpression context and act if
   they were in subexpression capture.  XXX really?

** PRED → EXPR₁ “=~” EXPR₂ | EXPR₁ “!~” EXPR₂ — regex matching

   EXPR₁ is a string to be match by regular expression at EXPR₂.
   EXPR₁ and EXPR₂ are evaluated in subexpression context and act if
   they were in subexpression capture.  XXX really?

** PRED → “if” EXPR₁ — subexpression conditional

   This is exactly equivalent to ({EXPR₁} != {}).

   : (! if /) # keep childless DIE's only

** PRED → “.show” | “.dump” — debugging

   Both predicates always succeed, and print elements that they are
   tested on.

   - .show shows only the value
   - .dump shows debugging information as well--fuller output,
     attached values, that sort of thing

* Representing non-.debug_info information

** @decl_file

   The value is represented as actual string including path.

** @stmt_list

   $@stmt_list yields a number of pseudo-DIE's of type
   line_table_entry.  Each has the following attributes: @address,
   @op_index, @file, @line, @column, @is_stmt, @basic_block,
   @end_sequence, @prologue_end, @epilogue_begin, @isa,
   @discriminator.

** @location

   $@location yields a number of pseudo-DIE's of type
   location_list_entry.  Each has the following attrubets: @address,
   and @ops.

   $@ops yields a number of pseudo-DIE's of type location_list_op.
   Each has the following attributes: @atom (which contains opcode),
   and possibly @number or also @number2 (with operands).

   - XXX possibly a means of evaluating?

** ELF symbols

* Examples
** Josh Stone's nontrivial-parameters script

   : (?subprogram && ! ?@declaration
   :  && !($@decl_file =~ "^/usr/" && $@decl_file !~ "^/usr/src/debug")) -> A
   : / ?formal_parameter -> B
   : $@type ((const_type || volatile_type || typedef) $@type)*
   : (?structure_type || ?class_type)
   : {"%{ $A $@decl_file %}:%{ $A $@decl_line %}: note: in function ",
   :  "`%{ $A $@name }%', parameter `%{ $B $@name %}' type is not trivial"} concat

   - In XQuery, it is:

   : declare function local:cvPeeledType($root, $node) {
   :     let $T := $root//*[@id = $node/at_type] return
   :     if ($T/name() = "tag_const_type"
   :         or $T/name() = "tag_volatile_type"
   :         or $T/name() = "tag_typedef")
   :     then local:cvPeeledType($root, $T)
   :     else $T
   : };
   :
   : doc ("xxxxx.xml")//tag_subprogram/
   : (let $A := tag_formal_parameter
   :  let $T := local:cvPeeledType(/, $A)
   :  return if ($T/name() = "tag_structure_type")
   :         then concat ($A/../at_name/text(), ": type of parameter ",
   :                      $A/at_name/text(), " is not trivial.")
   : 	else ())

** check_die_decl_call:

   : ( (?@decl_column && !?@decl_line) "%s has decl_column, but NOT decl_line"
   : , (?decl_line && !?@decl_file) "%s has decl_line, but NOT decl_file"
   : , (?@decl_file && !?@decl_line) "%s has decl_file, but NOT decl_line"
   : , (?call_column && !?call_line) "%s has call_column, but NOT call_line"
   : , (?call_line && !?call_file) "%s has call_line, but NOT call_file"
   : , (?call_file && !?call_line) "%s has call_file, but NOT call_line" )

** check_die_line_info:

   : (?subprogram || ?inline_subroutine || ?entry_point || ?lexical_block
   :  || ?label || ?with_stmt || ?try_block || ?catch_block) -> A
   : ($@entry_pc, $@low_pc, $@ranges) -> B
   : /parent* ^
   : ({$@stmt_list ($A == $@address)} == {})
   : "Address %{$B%} referenced from %{$A%} not found in line table."

** contains DW_OP_fbreg && ! @frame_base
   : (! ?@frame_base) if ($@location $@ops $@atom == DW_OP_fbreg)

** uses register based operators
   : if ($@location $@ops (($@atom >= DW_OP_reg0 && $@atom <= DW_OP_regx)
   :                       || $@atom == DW_OP_bregx))

** whether it uses a deref operator
   : if ($@location $@ops $@atom
   :     if (-> A {DW_OP_deref, DW_OP_xderef, DW_OP_deref_size,
   :               DW_OP_xderef_size, DW_OP_GNU_deref_type} $A == $_))

** contains DW_OP_call_frame_cfa && $@low_pc == 0
   : $@low_pc == 0 && if ($@location $@ops $@atom == DW_OP_call_frame_cfa)

** is an empty location expression
   : ! if $@location

** location expression ends with implicit_value or stack_value
   : if ($@location $@ops (({$pos, 1} add) == :length)
   :     ($@atom == DW_OP_implicit_value || $@atom == DW_OP_stack_value))

* Old work
== check_duplicate_DW_tag_variable

--> check for two full DW_TAG_variable DIEs with the same DW_AT_name
    value

//variable[@declaration]

== check_linkage_external_die.cc

(SHT_DYNSYM | SHT_SYMTAB)/*[@type==STT_OBJECT or @type==STT_FUNC][@name != ""]
