-*-org-*-
* Introduction

  Dwgrep is a tool and an associated language for querying Dwarf
  (debuginfo) graphs.  If you want to find out more about Dwarf, you
  may check out the following links.  But you can also pretend that
  Dwarf is like XML, except nodes are called DIE's.  That, and
  perusing the output of eu-readelf -winfo, should be enough to get
  you started.

    http://www.dwarfstd.org/doc/Debugging%20using%20DWARF.pdf
    http://dwarfstd.org/Download.php

  You can think of dwgrep expressions as instructions describing a
  path through a graph, with assertions about the type of nodes along
  the way: that a node is of given type, that it has a given
  attribute, etc.  There are also means of expressing sub-conditions,
  i.e. assertions that a given node is acceptable if a separate
  expression matches (or doesn't match) a different path through the
  graph.

  Apart from Dwarf objects (DIE's and Attributes), dwgrep expressions
  can work with integers, strings, and sequences of other objects.

  In particular, a simple expression in dwgrep might look like this:

  : ?subprogram child ?formal_parameter @name

  Which (ignoring the initial colon that's part of meta-syntax) says:
  show me values of attribute DW_AT_name of DW_TAG_formal_parameter
  nodes that are children of DW_TAG_subprogram nodes.  Reading
  forward, you get list of instructions to a matcher: accept all
  DW_TAG_subprogram's, look at their children, accept those that are
  DW_TAG_formal_parameter, take value of attribute DW_AT_name.

  Another example comes from dwarflint:

  : ?@decl_column !@decl_line

  ... which looks for DIE's that have DW_AT_decl_column, but don't
  have DW_AT_decl_line--a semantic violation that is worth reporting.


* Computation

  Conceptually, dwgrep expressions form a pipeline of functions.  The
  Dwarf graph under consideration flows through this pipeline,
  modified by each function of the overall expression, and whatever
  comes out of the other end is the result of the query.

  We call what flows through the dwgrep expression a /working set/.
  Initial working set contains all DIE's in a given Dwarf graph.  As
  the working set is transformed, its elements can be more than just
  DIE's--as mentioned, they can be also integers, strings, etc.

  Each function takes on input an element of the working set, and
  produces zero or more elements on the output.  Note that producing
  several elements is different from producing an element that holds a
  single value of type sequence.  When a function is applied on a
  working set element, the following can happen:

  - that element is removed (if a function doesn't yield anything)
  - the element is changed for another
  - that element is "forked", replaced with several elements

  When dwgrep expression is evaluated, the functions in the expression
  are applied to each element of the working set, and the output is
  collected to form a new working set.  The whole scheme is thus
  reminiscent of shell pipeline, except you have richer variety of
  types instead of lines.

  There is a subtle difference between values and elements: elements
  contain /stacks/ of values.  Functions in the pipeline consume one
  stack on input, and produce zero or more stacks on output.  If
  nothing is produced, that means that the computation stopped making
  sense: some assertion didn't hold, or an attribute was expected that
  was not available.  Such element is removed from the working set.
  On the contrary, a function can produce several stacks, which means
  that several possible paths forward exist.  The values on stack
  provide a context to the result.


* Introduction to the dwgrep language

  In following, examples are generally written as follows:

  : blah blah lorem ipsum stuff

  The initial colon is not part of the example, but an artifact of
  Emacs org mode.

** ?ID — DIE tag assertion

   The assertion "?ID" takes the value at top of stack (TOS).  If what
   is there is not a DIE, or it's a DIE whose tag is not DW_TAG_ID,
   this function yields nothing.  Otherwise it yields the input stack
   unchanged.

   For example, to list all subprograms, one would use the following
   expression:

   : ?subprogram

** ?@ID, !@ID — attribute presence/absence assertion
** EXPR₁ EXPR₂ … — concatenation

   "?@ID" holds if the value on TOS is a DIE with DW_AT_ID.

   In dwgrep, function pipelines are formed by simply placing
   functions next to each other.  The stacks that the left function
   produces becomes an input of the right function.  For assertions,
   this happens to work as a logical and.

   For example, this is how we can get a list of all subprograms that
   have a declaration attribute:

   : ?subprogram ?@declaration

   Similarly, to get subprograms that do not have declaration
   attribute, we say:

   : ?subprogram !@declaration

** if, else, not — conditionals

   Unfortunately, mere ?@declaration doesn't tell us whether a DIE is
   a pure declaration.  We can probably safely assume that when a
   compiler produces that attribute, it will actually have a value of
   true, so most of the time ?@declaration (and !@declaration) is all
   you need to write.  But if we are paranoid, or have grounds for
   suspicion this is not so, we need to actually look at
   DW_AT_declaration's value.

   "if" expects a value on TOS.  If it's an empty list or a false, it
   rejects the computation.  If it's non-empty list or a true, it
   accepts it.  Thus to figure out whether a DIE represents a
   subprogram declaration, we can say:

   : ?subprogram @declaration if

   "else" behaves in the opposite way.  So to see if something is not
   a pure declaration (which is what we are after), we might say:

   : ?subprogram @declaration else

   But that apparently dangling else is fairly awkward.  For this
   reason, there's "not", which switches truthfulness of the value on
   TOS:

   : ?subprogram @declaration not if

   "if", "else" and "not" drop the value on TOS (they are not
   assertions, as indicated by lack of ? or ! in their name).  "not"
   additionally pushes a new value.

   In following, we are not paranoid, and assume that ?@declaration
   and (@declaration if) have the same effect.

** child — child traversal

   This function drops the DIE at TOS, and produces a set of stacks,
   each with one child pushed to TOS.  If applied on a childless DIE
   or on a value that's not a DIE at all, it produces nothing, and
   such computations are thus dropped.  To get at the formal arguments
   of the subprograms from the previous example, one might say:

   : ?subprogram !@declaration child

   If we want to make sure these children are actually formal
   parameters:

   : ?subprogram !@declaration child ?formal_parameter

** @ID — value of attribute DW_AT_ID

   This is the first example of a function that can produces something
   else than Dwarf DIE's.  This will replace the DIE at TOS with a
   value of the attribute of that DIE.  E.g. we could obtain names of
   the formal parameters selected above:

   : ?subprogram !@declaration child ?formal_parameter @name

   The result would be a set of strings with names of all formal
   parameters in the program.  That's not very useful, as that just
   lists a bunch of names.

   But there's another use of this same feature: for attributes with
   reference form, we get the effect of traversing over the edge
   rooted at given attribute.  For example, we could get types of
   formal parameters thus:

   : ?subprogram !@declaration child ?formal_parameter @type

   ... which is a bit more useful.  We might use this to discover
   whether some formal parameters have structure types, and would
   therefore incur a potentially expensive copy when the subprogram is
   invoked:

   : ?subprogram !@declaration child ?formal_parameter @type ?structure_type

   So that will let us know whether there are any offenders like that.
   That's closer to being interesting, but not quite what we need
   either.  We would like to know about the subprograms themselves,
   that have this property!  Hence:

** ?(EXPR), !(EXPR) — Sub-expressions assertions

   Some dwgrep expressions are evaluated in what we call a
   sub-expression context.  What happens in sub-expression context,
   stays there--the stack effects of sub-expression computation never
   leak back to working set.

   ?(EXPR) expression is one such case.  It asserts that EXPR produces
   at least one element.  We can use it to get to DIE's that have
   arguments that are structures:

   : ?subprogram !@declaration ?(child ?formal_parameter @type ?structure_type)

   This asks whether, after going to types of children that are formal
   parameters, we get a structure.  Because the initial two assertions
   have no stack effects anyway, we might say the same thing thus:

   : ?(?subprogram !@declaration child ?formal_parameter @type ?structure_type)

   The other sub-expression assertion, !(), holds if EXPR produces no
   values at all.  We don't need that, but we could use it to reword
   the query thus:

   : ?subprogram !(?@declaration)
   : ?(child ?formal_parameter @type ?structure_type)

   If a DIE is a pure declaration, the expression ?@declaration yields
   unchanged incoming stack.  But !() only holds for expressions that
   yield nothing at all, thus such DIE's are rejected.

   But there's more than DW_TAG_structure_type, we care about
   DW_TAG_class_type as well!  We can express "and" easily simply by
   juxtaposing the assertions, but we would like a way of expressing
   "or" as well!

** EXPR, EXPR — alternative paths

   This expression evaluates all constituent EXPR's with the same
   input, and then yields all values that each EXPR yields.  If the
   expressions are assertions, this happens to behave exactly like a
   logical or.  So:

   : ?subprogram !@declaration
   : ?(child ?formal_parameter @type (?structure_type, ?class_type))

   So this is fine, but it still shows only functions that take
   structure (or class) arguments directly.  But what if they take a
   const argument?  Or if they take a typedef that evaluates to a
   structure?  For these cases we need to keep peeling the fluff until
   we get to the interesting DIE's.  Enter iterators:

** EXPR*, EXPR+, EXPR? — expression iteration

   - EXPR* leaves the working set unchanged, then adds to that the
     result of one application of EXPR, then of another, etc.  It
     works similarly to * in regular expressions.
   - EXPR+ is exactly like EXPR EXPR*.
   - EXPR? is the same as (, EXPR) — it /may/ apply once

   We can use this tool to remove const_type, volatile_type and
   typedef layers from our potential structure:

   : ?subprogram !@declaration
   : ?(child ?formal_parameter
   :   @type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type))

   Next on, we would like to write a message:

** Literals, Strings, Formatting

   dwgrep understands roughly C-like string literals, using \ as an
   escape character.  Hello world looks like this in dwgrep:

   : "Hello world!"

   This is an example of a string literal.  Literals in dwgrep add
   themselves to the stack.  There are many literals in dwgrep--apart
   from strings and usual numeric literals, dwgrep knows about all the
   named Dwarf constants--e.g. DW_AT_name, DW_TAG_array_type,
   DW_FORM_flag, etc. are all valid dwgrep forms.

   Like C printf, string literals in dwgrep allow formatting
   directives.  To write a nice error message for our running example,
   we could do for example:

   : ?subprogram !@declaration
   : ?(child ?formal_parameter
   :   @type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type))
   : "%s: one of the parameters has non-trivial type."

   When dwgrep sees a string with formatting directives, it converts
   it into a function.  That function pops one parameter for each %s,
   interpolates them all, and then pushes the result to stack.
   Consequently, to convert anything to a string in dwgrep, you would
   just say:

   : "%s"

   The output that our running example above gives would print
   something like this:

   :  .debug_info@0x420: type of one of the parameters is not trivial.

   We would like to improve on that a bit.  We'd like to mention which
   parameter it is, and we'd like to tell the user the name of the
   function, not just a DIE offset.  We'll address both.

** -EXPR — Sub-expression evaluation

   When decorated like this, EXPR is evaluated in subexpression
   context (?() and !() described above are another expressions
   evaluated like this).  EXPR is evaluated on a copy of incoming
   stack, after which TOS of the sub-stack is pushed on top of
   incoming stack.

   dwgrep words, except for assertions, implicitly drop the operands
   that they work with.  "-" is an easy way to make them preserve the
   stack and only push the resultant value.

   We can use this to keep two DIE's on stack in our in-progress
   script: the subprogram itself as well as the struct argument.

   : ?subprogram !@declaration -child ?formal_parameter
   : ?(@type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type))
   : "Parameter %s of %s has non-trivial type."

   So that's nice, but notice how we needed to change the message to
   reflect order of values on stack.  For these reasons, dwgrep has a
   suite of stack-shuffling words from Forth:

** Stack shuffling

   - "dup" duplicates top element of stack.
   - "swap" swaps top two stack elements.

   Apart from these two, dwgrep includes over, rot and drop.  See
   below for their definition.  With swap, we can get our message in
   the right order:

   : ?subprogram !@declaration -child ?formal_parameter
   : ?(@type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type)) swap
   : "%s: Parameter %s has non-trivial type."

   And now we can also transform each stack slot to its name, so that
   the message doesn't mention unfamiliar loci, but names:

   : ?subprogram !@declaration -child ?formal_parameter
   : ?(@type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type)) @name swap @name
   : "%s: Parameter %s has non-trivial type."

   Now the idiom "X swap X" is very common in dwgrep expressions.
   Typically you would use it to tie DIE's from two sets together.
   E.g. in dwarflint, there's a check that a scope doesn't contain two
   variables of the same name.  You can implement the check thus:

   : dup child ?variable swap child ?variable !eq ?(@name swap @name ?eq)

   We get the same "X swap X" idiom, and twice!  Clearly this is
   useful relatively often, so dwgrep has a syntax for this:

** N / EXPR — pathset exploration

   This form applies EXPR to the top N stack elements, with N a
   compile-time constant with value greater than 0.  With this tool,
   we can rephrase the above check like this:

   : dup 2/(child ?variable) !eq ?(2/@name ?eq)

   Which is much better.  We can also use it to improve our
   non-trivial parameters script (but not much, we'll still need to
   swap):

   : ?subprogram !@declaration -child ?formal_parameter
   : ?(@type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type)) 2/@name swap
   : "%s: Parameter %s has non-trivial type."

   Ideally we'd also include source code coordinates for the function
   name.  dwgrep formatters have a tool for this: you can enclose
   arbitrary expressions between %( and %).  They are executed, TOS is
   then popped and embedded in the template:

   : ?subprogram !@declaration -child ?formal_parameter
   : ?(@type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type)) swap
   : "%( -@decl_file %): %( -@decl_line %): note: in function \
   : `%( @name %)', parameter `%( @name %)' type is not trivial."

   So, that's it.  This was a quick tour through the interesting parts
   of dwgrep language.  In the following sections, all of it will be
   introduced in a semi-formal, but rather terse format.


* Stack maintenance

  A stack of values is maintained for each computation context (in
  fact the stack is that context).  Various expressions treat the
  stack in various ways.  In particular

  - initially the stack is composed of a single value of type DIE

  - assertions inspect TOS (or several values on TOS), test the
    condition, and either leave the stack unchanged, or abort the
    computation.  They do not pop.  This includes ?@at, !@at, ?tag,
    !tag, ?(), !(), ?all(), ?eq, !eq, ?gt, ?match, etc.  All
    assertions start either with a ? (if it's positive assertion), or
    with a ! (if it's negative assertion).

  - stack shuffling operators (swap, drop, dup, ...) reorder values on
    the stack

  - literals push a new value on stack
    - integers (1, 0x20, -7)
    - strings ("Ahoj!")
    - sequences ([1, 2, 3])
    - constants (DW_AT_name, DW_FORM_ref_addr, ...)

  - all other forms are called functions.  They pop TOS (possibly
    several times) and push another value depending on those values
    that were popped.  This includes traversal forms (@at, child,
    parent, etc.) and operators (sub, add, etc.).

  - "-" evaluates the following sub-expression on a separate stack,
    and pushes the sub-stack's TOS on current stack.

  dwgrep expressions make it possible to determine stack size
  statically.  dwgrep uses this extensively to remove stack shuffling
  where possible, and to remove stack copying for sub-expression
  evaluation (i.e. <X> <Y> <protect <add a=0;b=1;dst=0> a=0;dst=2> can
  be replaced with <X> <Y> <add a=0;b=1;dst=2>).


* Overview of dwgrep language

  - • means implemented
  - · means partially implemented

** •EXPR → EXPR₁ EXPR₂ — concatenate

   The constituent EXPR's may yield more than one output value.  A new
   working set is formed by gathering all these returned values.  If
   you wish to get an actual list of values instead, see below for []
   operator, which captures the resulting values and wraps them in a
   sequence.

** •EXPR → EXPR₁ “,” EXPR₂ … — alternate

   EXPR yields all the values that EXPR₁ and EXPR₂ yield.  In practice
   this can be used as logical or, or to construct literal lists.

   All constituent EXPR's shall have the same overall stack effect
   (the number of slots pushed - number of slots popped will be the
   same for each branch).

   - For example, to follow through all edges:
     : (child, attribute ?(form "%s" "DW_FORM_ref.*" ?match))

** •EXPR → NUM “/” EXPR₁ — pathset exploration

   The effect is as if the topmost NUM elements were removed from
   stack and remembered as X₁ to Xₙ, with Xₙ the original TOS.  Then
   X₁ is pushed, and EXPR₁ executed.  Then X₂ is pushed, and EXPR₁
   executed again.  Etc.

   (This semantics were chosen to make the operator widely applicable,
   but the particular problem that this addresses is simultaneous
   exploration of several paths, and we may revert to semantics where
   the only stack effects allowed (apart from nothing at all) are a
   single pop followed by a single push.)

   The idiom whereby an operator is applied, values swapped, and the
   same operator is applied again, comes up very often.  Clearly there
   should be syntax for it.

   - Compare names of two DIE's on TOS:
     : ?(@name swap @name ?eq)
     : ?(2/@name ?eq)

   - Follow the same traversal instructions for two DIE's on TOS:
     : child ?formal_parameter swap child ?formal_parameter
     : 2/(child ?formal_parameter)

   - rot is exactly equivalent to:
     : 2/swap
     It is thus easy to achieve deep rotation: top four items are
     rotated by 3/swap etc.  This relies on the above liberal
     definition of N/expr.

**  EXPR → “-” EXPR₁ — evaluation in sub-expression context
   EXPR₁ is evaluated on a separate stack, whose TOS is then copied to
   the incoming stack and produced as a result.

** •EXPR → EXPR₁ “*” | EXPR₁ “+” | EXPR₁ “?” — iterate

   EXPR₁ shall have a stack effect of +n,-n (number of slots pushed
   equals number of slots popped).

   - Example: explicit for loop
     : 0 (1 add ?(10 ?lt))*

** •EXPR → (“0x”|“0”|“”)[1-9][0-9]* — literals
** ·EXPR → “r”? “"” (formatting string) “"”
   - %( and %) enclose an EXPR that's evaluated in plain context, and
     whose input is whatever is the input to the string literal
     itself.  TOS is then popped, converted to a string and embedded
     in the string template.

   - %s stands for %( %)
   - %d stands for %( value %)
   - %x stands for %( value hex %)
   - %o stands for %( value oct %)
   - %% stands for a single %

   - The resulting string is pushed to stack after all interpolations
     are processed one after another.

   - The r"" strings are raw strings.  They work the same as normal
     formatting strings, but escape sequences are left intact in the
     string.

**  EXPR → (“?”|“!”)(literal) | (“?”|“!”)(named constant) — value assertions

   Since majority of comparisons are ?eq or !eq anyway, and many of
   those are vs. constants, there's a syntax for asserting a value.
   This is allowed for string literals, numeric literals, or named
   constants.

   According to a value on TOS, and a constant family, the following
   rewrire rules define the semantics of a value assertion:

   |----------+----------------+-----------------|
   | v        | TOS            | Meaning of ?v   |
   |----------+----------------+-----------------|
   | DW_TAG_  | T_NODE         | ?(tag ?v)       |
   | DW_AT_   | T_NODE         | ?(attribute ?v) |
   | DW_AT_   | T_ATTR         | ?(name ?v)      |
   | DW_FORM_ | T_ATTR         | ?(form ?v)      |
   | any      | T_ATTR         | ?(value ?v)     |
   | any      | T_CONST, T_STR | ?(v ?eq)        |
   |----------+----------------+-----------------|

   For example, ?DW_ATE_unsigned is applicable to an attribute that is
   DW_AT_encoding, or a constant of that domain.  ?"foo" is applicable
   to a DW_FORM_string or DW_FORM_strp attribute, or another string.
   Etc.

   - Example: asking for a qualified name:
     : ?(@name ?"a") child ?(@name ?"b") child ?(@name ?"c")

**  EXPR → (“universe” | “section” | “unit” | “winfo” )

   - "universe" stands for every DIE (and pseudo-DIE) in Dwarf graph.
     Unlike section and unit, it doesn't drop.

   - "section" is similar, but selects only DIE's (or pseudo-DIE's)
     that come from the same section as value on TOS -- e.g. from
     .debug_info, from symbol table, etc.

   - "unit" selects objects belonging to the same logical unit.  This
     may mean a CU, a current line table, etc.

   - "winfo" selects .debug_info.  XXX The rest is not yet in.

   - XXX We might need "unit" to mean "the CU that we came from" and
     something else to mean "local set of entities".

** •EXPR → “(” EXPR₁ “)” — grouping, precedence

**  EXPR → “[” EXPR₁ “]” | “[” “]” — list generator

   - The stack ordering after EXPR₁ has been applied must be the same
     as before EXPR₁, with possible exception of EXPR₁ doing one
     additional push.  In particular:

     : 1 2 [()]		# OK -- no action
     : 1 2 [3]		# OK -- single push
     : 1 2 [-child]	# OK -- single push
     : 1 2 [child]	# OK -- a pop followed by a push
     : 1 2 [drop 1]	# OK -- a pop followed by a push
     : 1 2 [drop]	# not OK
     : 1 2 [swap]	# not OK
     : 1 2 [-drop]	# OK -- a single push (drop is in subexpression context)

   - [ EXPR₁ ] evalueates EXPR₁.  It then collects all results that it
     produces, pops TOS of each of these results, and stores these
     TOS's into a sequence.  It then produces one stack per unique
     stack collected with the sequence pushed on top.

     If EXPR₁ yields nothing, then [ EXPR₁ ] produces an incoming
     stack with an empty list on top, pushed to the slot where EXPR₁
     would push the list.  This is the reason behing the above
     limitation--the list generator expression needs to know where to
     put the empty list even if EXPR₁ doesn't yield anything.

     Some examples:

     : [1, 2, 3]	# push a list with elements 1, 2 and 3
     : [()]		# wrap TOS in a one-element list
     : [child]		# replace each node with a list of its children
     : [child*]		# replace each node with a list of all descendants

     The first example is note-worthy.  Since integer literals push a
     new element on TOS, the original stack is left unchanged.  The
     1,2,3 syntax is not special to list generator, but is ordinary
     alternation syntax, described above.

   - [] is a literal that produces an empty list.  It is exactly
     equivalent to (among others):
     : [ 0 !0 ]

   - over is exactly equivalent to:
     : [ -drop ] each
   - dup is exactly equivalent to (among others):
     : [ -() ] each

**  EXPR → “{” EXPR₁ “}” | “:”ID — blocks, symbols

    - {X} -- A block syntax.  A value representing an expression X is
      pushed on TOS.

    - :ID -- A symbol syntax.  A value representing symbol ID is
      pushed on TOS.  Normally mentioning a word such as "swap" leads
      directly to that action being performed.  ":swap" instead pushes
      the symbol to TOS.

    - def -- pop symbol on TOS and value below TOS.  In local scope,
      bind the symbol to that value.

      If a def'd symbol is mentioned later (without the ":"), the
      value it's bound to is pushed to the stack.  If the value is a
      block, that block is executed.

      : { dup add } :double def
      : 3 double		# gives 6

      : { :x def ... }		# within {}, x refers to whatever was on TOS
      : { :x def :y def ... }	# x is what was on TOS, y is what was below TOS

      XXX since {} and :X are both literal forms, and "def" is just an
      ordinary word, this all takes place at runtime.  Hence we don't
      know what a word refers to until we look it up, and that may
      pose serious performance overhead (some tens of millions of
      lookups are bound to be noticeable).

      XXX This also kills pre-computing of stack slots.  But that was
      a problem for extensibility anyway, so maybe it would have to go
      away sooner or later anway.

      The above definition allows for recursive functions as well,
      since the names have to be resolved at runtime anyway:

      : { :n def n 1 eq (if 1, else n n 1 - fact *) } :fact def
      : 3 fact	# 6

    - XXX eval -- resolve symbol on TOS to whatever it's bound to.

    - x -- if a symbol is on TOS, then eval it.  Then expect a block
      on TOS, which is executed.

      The execution introduces a new activation record (dynamic scope)
      inside the current scope.  Any def's bind symbols in this new
      scope, and words are looked up in this scope as well (but of
      course proceed upwards if the symbol is not found).  Any block
      literals inside this execution remember the scope (which in turn
      remembers its surrounding scope, even if the execution already
      left it), so that they work as closures.

      : { :x def { :y def x y + } } :adder def
      : 2 adder 1 swap call

      : { :f def [ each f xc ] } :map def

    - XXX sx -- pop TOS and avaluate it in sub-expression context,
      push TOS of sub-stack on TOS of outer stack.

    - + -- pop a block on TOS, then evaluate its transitive closure
    - * -- likewise for transitive reflexive closure

    - Examples: dip, dip2, dipn:
      : { :op def :tmp def op tmp } :dip def
      : 1 2 3 { swap } dip	# 2 1 3

      : { :op def { { op } dip } dip } :dip2 def
      : 1 2 3 4 { swap } dip2	# 2 1 3 4

      : { :n def :op def
      :   n 0 eq (if op, else :tmp def { op } n 1 - dipn tmp) } :dipn def
      :
      : 1 2 3 4 { swap } 0 dipn	# 1 2 4 3
      : 1 2 3 4 { swap } 1 dipn	# 1 3 2 4

      : { :op def op op } :twice def
      : 1 2 3 4 { add } twice	# 1 9

      : { foo } :bar def
      : { :op def  2 :foo def  op } :baz def
      : { bar } baz		# 2

      : { :tbr def :fbr def (?true tbr, ?false fbr) } :ifelse def
      : -[ child ] length 0 eq { "empty" }{ "non-empty" } ifelse

    - N/X can be made into {X} N topn:
      : { :n def :op def
      :   n 0 eq (if, else { op } n 1 - dipn
      :                    { op } n 1 - topn) } :topn def

      : 1 2 3 { 1 + } 1 topn	# 1 2 4
      : 1 2 3 { 1 + } 2 topn	# 1 3 4

    - {X} ? and {X} ! could assert whether X produces anything.
      : { dup [] eq if } "?empty" def
      : { dup [] ne if } "!empty" def
      : { :op def {[ op ]} sx !empty drop } "?" def
      : { :op def {[ op ]} sx ?empty drop } "!" def

      But I guess we might as well keep the original ?{}, !{} syntax.
      We might as well introduce -{}, ={} or something for execution
      in sub-expression context, as that's wildly useful.

    - Stack shuffling operators:
      : { :a def } :drop def
      : { :a def a a } :dup def
      : { :a def :b def a b } :swap def
      : { :a def :b def :c def b a c } :rot def
      : { :a def :b def b a b } :over def

**  EXPR → “?(” EXPR₁ “)” | “!(” EXPR₁ “)” — sub-expression assertions

   These ask whether TOS of [ EXPR₁ ] would be, respectively, a
   non-empty or empty list.

   - ?( EXPR₁ ) is exactly equivalent to:
     : -[ -EXPR₁ ] !empty drop
   - !( EXPR₁ ) is exactly equivalent to:
     : -[ -EXPR₁ ] ?empty drop

   - Examples:
     : !(child)       # keep leaf DIE's only

**  EXPR → (“?all(” | “!all(”) EXPR₁ “)” — quantifier assertion

   - ?all(EXPR₁) is exactly equivalent to:
     : ?([each ?(EXPR₁)] 2/length ?eq)
   - !all(EXPR₁) is exactly equivalent to:
     : ?([each ?(EXPR₁)] 2/length !eq)

   - I.e. it expects a list on TOS.  This list is forked into
     individual computations by "each".  For ?all, only if each of
     these computations yields a value does the overall predicate
     succeed.  For !all, only if at least one fails does the overall
     predicate succeed.  The list on TOS is kept.

**  EXPR → “if” EXPR₀ “then” EXPR₁ “else” EXPR₂ — conditionals

   - EXPR₀ is evaluated in sub-expression context.  If it yields
     anything, EXPR₁ is evaluated in plain context.  Otherwise EXPR₂
     is evaluated in plain context.

**  EXPR → EXPR₁ (“while” | “until”) EXPR₀

   - The "while" loop evaluates EXPR₁ as long as EXPR₀ holds.  In each
     iteration, it checks whether EXPR₀ holds for every computation
     under consideration.  The computations for which EXPR₀ doesn't
     hold are yielded unchanged.  To others, EXPR₁ is applied and what
     this yields is added into consideration.  Then another iteration
     is done.

     : (if EXPR₀ then EXPR₁ else ())* !(EXPR₀)

   - The "until" loop has the same mode of operation, but meaning of
     EXPR₀ is reversed.

     : (if EXPR₀ then () else EXPR₁)* ?(EXPR₀)

   - EXPR₁ has to have neutral stack effect.

** ·EXPR → “swap” | “dup” | “over” | “rot” | “drop” — stack shuffling

   These words reorder elements on stack according to the following
   schemes:

   |------+---------+-----------|
   | op   | before  | after     |
   |------+---------+-----------|
   | dup  | A B C D | A B C D D |
   | over | A B C D | A B C D C |
   | swap | A B C D | A B D C   |
   | rot  | A B C D | A C D B   |
   | drop | A B C D | A B C     |
   |------+---------+-----------|

   Realistically, most of what end users should write will be an
   occasional dup, possibly a swap.  Drop shouldn't be needed (that's
   what sub-expressions are for), and the deep stack manipulation
   should be unnecessary as well.  But they are present for
   completeness' sake.

** •EXPR → “each” — pop a list, yield all its elements

   - "each" pops a list, and for each element yield a stack with that
     element pushed on top

   - To zip contents of two top lists near TOS, do:
     : 2/each ?(2/pos ?eq)

     This takes two lists from the stack, and produces stacks that
     have those two elements replaced with individual elements from
     those lists that correspond to each other.  For example:
     : A B [C₁, C₂, C₃] [D₁, D₂, D₃]

     ... would be replaced with three stacks:
     : (A B C₁ D₁, A B C₂ D₂, A B C₃ D₃)

   - Similarly for deeper, three-level zip:
     : 3/each ?(3/pos 2/?eq)

** ·EXPR → “child” | “attribute” | “parent” | “next” | “prev” — traversal

   - "child" pops DIE on TOS and yields one stack for each child,
     with that child pushed to TOS.

   - "attribute" does the same with attributes instead of children

   - parent is exactly equivalent to:
     : universe ?(child ?eq) swap drop
     Note that in case of imported units, "parent" may return more
     than one DIE!  (XXX This doesn't seem desirable?)

   - next is exactly equivalent to:
     : dup parent child ?eq swap drop
     : dup pos 1 add swap parent child ?(pos rot ?eq) swap drop
     The first line is necessary to make sure that pos later refers
     to order in children array, not to e.g. a result of ([XYZ] each).

   - prev can be defined in manner similar to next.

** •EXPR → “?root” | “!root” — root node assertion

   - !root is exactly equivalent to:
     : ?(parent)
   - ?root is exactly equivalent to:
     : ?(type T_NODE ?eq) !(parent)

   - Examples:
     : parent* ?root        # finds a root node of node on TOS

** ·EXPR → “@”ID — attribute value

   This function pops a DIE off TOS and pushes a value of its
   attribute DW_AT_ID.  If you want to access the attribute object
   itself instead, use:

   : attribute ?@ID

** •EXPR → “offset”|“name”|“tag”|“form”|“value” — Dwarf tree introspection

   - "offset" pops DIE or Attribute on TOS and pushes a value
     representing offset of the object in Dwarf file.

   - "name" pops DIE or Attribute on TOS and pushes a value
     representing, respectively, a tag or attribute name.

   - "tag" is like "name", but only valid for DIE's.

   - "form" pops Attribute on TOS and pushes back a value
     representing its form.

   - "value" pops Attribute on TOS and yields one stack for each
     value associated with this Attribute, with that value pushed to
     TOS.  Typically this would yield a single stack with a string or
     integer on top, but it may yield e.g. several pseudo-DIEs for
     things like @stmt_list.

** •EXPR → “?”ID | “!”ID — DIE tag assertion

   - ?ID is exactly equivalent to:
     : ?(tag DW_TAG_ID ?eq)
   - !ID is exactly equivalent to:
     : ?(tag DW_TAG_ID !eq)
   - Note that either form fails when applied to a non-DIE value.

** •EXPR → “?@”ID | “!@”ID — attribute presence/absence assertions

   - If the value on TOS is a DIE, these forms assert that they have
     (don't have) an attribute with a given name.

     - Instead of using "?@ID", one can also simply access the
       attribute value with "@ID".  If such attribute is not
       available, that computation is aborted.

   - If the value on TOS is an Attribute, these forms assert that the
     attribute has a given name.

** •EXPR → “type” — TOS introspection

   This produces an integer value suitable for comparison with the
   following constants:

   - T_NODE — for Dwarf_Die's, and Dwarf_Line's and other pseude-DIE's
   - T_ATTR — for Dwarf_Attribute's and other attribute-like pseudos
   - T_SEQ — for sequence objects
   - T_STR — for string objects
   - T_CONST — for integer objects
   - T_FLOAT — for floats

** •EXPR → “pos” | “count” — pos of element within producing expression

   Each function numbers elements that it produces, and stores number
   of each element along with the element.  That number can be
   recalled by saying "pos".  "count" then contains count of values
   produced.

   - Count is potentially expensive.  The producers therefore don't
     count all values up front.  Instead we can determine which
     producers potentially produce the values that count is applied
     to, and then replace the producer X with [X] each.

   - The same holds for ?last.

**  EXPR → “?first” | “?second” | “?third” | “?last” — position assertion

   (And corresponding ! forms.)

   Assertion on position of tested element within expression that
   generated it.  If an expression generates elements X, Y, and Z on
   top of existing stack A B C, three stacks come out: A B C X, A B C
   Y, and A B C Z.  "?first" would be true in context of A B C X, etc.

   - ?first is exactly equivalent to:
     : ?(pos 0 ?eq)
     (and similarly for ?second, ?third, ...)

   - ?last is exactly equivalent to:
     : ?(-count 1 sub swap pos ?eq)

   - Examples:
     : each ?last	# get last element of a list on TOS
     : [each !first] swap each first   # split a list into head:rest

**  EXPR → “1st” | “2nd” | “3rd” | “last” | “nth” — sequence access

   - nth expects a constant on TOS and a sequence or a string one
     below TOS.  Extracts nth element of that.  (X N nth) is exactly
     equivalent to:
     : X each ?(pos N ?eq)

   - first, second, third and last extract the given element of
     sequence on TOS.  X Y, for Y in (first, second, third, last), is
     exactly equivalent to:
     : X each ?Y

** ·EXPR → “add” | “sub” | “mul” | “div” | “mod” — arithmetic

   - Two elements are popped: A and B, with B the original TOS, and "A
     op B" is pushed again.

   - Undefined operations (such as division by zero) simply abort the
     computation in question.

   - XXX how to sum a list?

** •EXPR → (“?”|“!”)(“eq”|“ne”|“gt”|“ge”|“lt”|“le”) — comparison assertions

   - Two elements are inspected: TOS and one below that (B and A,
     respectively).  The assertion holds if A op B is true.  Comparing
     values of different types is not defined, and such assertions
     fail as well.

   - Note that there is both !eq and ?ne, !lt and ?ge, etc.  These
     are mostly for symmetry--the assertions need "?" to denote that
     they are assertions, so why not have "!" forms as well.  For !eq
     it even makes a good sense.

   - Certain integer values have enum-like characteristics.  These
     include those produced by "tag", "name", "form", those produced
     by access to certain attributes (such as @language), and
     constants (e.g. DW_AT_name, DW_TAG_class_type, etc.).  For these
     values, dwgrep remembers their domain.  If two values are
     compared such that both have a domain assigned, and those domains
     differ, a warning is produced, because that's likely a flaw in
     the expression.

   - Examples:
     : A B swap? ?lt drop    # "max" -- keep the greater number on stack
     : A B swap? ?gt drop    # "min"

** •EXPR → (“?”|“!”)“match” — regex assertion

   This produces nothing when applied to non-string values.  Use "%s"
   to convert other value types to string.

   This is similar to “?eq” and “!eq”, except asserts that TOS (which
   is a string with a regular expression) matches the value below
   TOS.

   - "match" does a full-string match

**  EXPR → (“?”|“!”)“find” — search in a sequence

   - A B find looks for sub-sequence or sub-string B inside A
     (e.g. "haystack" "needle" find or -[hay stack] -[needle] find).

   - To determine, whether a sequence contains a particular element,
     you would use the following construct:
     : [that sequence] ?(each -that element ?eq)
     E.g.:
     : [-child @name] ?(each ?"foo")
     : [-child] ?(each @name ?"foo")

** •EXPR → “length” — length of a sequence or a string

**  EXPR → (“?”|“!”)“empty” — list/string emptiness assertion

   - ?empty is exactly equivalent to:
     : [] ?eq drop
   - !empty is exactly equivalent to:
     : [] !eq drop

**  EXPR → “demangle” — demangle a string on TOS

**  EXPR → “?dump” — debug assertion

   Always succeeds, but as a side effect prints some information about
   the computation in whose context it appeared.


* TODO

** @decl_file — represented as actual string including path
   (XXX we ignore mtime and size.  Those aren't stored anyway, but
   maybe it would be useful to have them so that one can do this sort
   of querying in the first place--do we have any files where this is
   stored?  Or after it gets to be stored in general, where this is
   _not_ stored?)

** @high_pc constant, @entry_pc constant — convert to full address???
   http://dwarfstd.org/ShowIssue.php?issue=120719.1

   This could be optionally interpreted, i.e. @high_pc whose form is
   DW_FORM_data* would actually yield a value computed from
   DW_AT_ranges or DW_AT_low_pc.

** @MIPS_linkage_name — translated to @linkage_name automatically

** @stmt_list

   @stmt_list yields a number of pseudo-DIE's of type
   line_table_entry.  Each has the following attributes: @address,
   @op_index, @file, @line, @column, @is_stmt, @basic_block,
   @end_sequence, @prologue_end, @epilogue_begin, @isa,
   @discriminator.

** @location

   @location yields a number of pseudo-DIE's of type
   location_list_entry.  Each has an attribute: @address.

   The children of location_list_entry are pseudo-DIE's of type
   location_list_op.  Each has the following attributes: @atom (which
   contains opcode), and possibly @number or also @number2 (with
   operands).

   - XXX possibly a means of evaluating?

** ELF symbols

   Each symbol table entry (in SHT_SYMTAB, SHT_DYNSYM and minisymtab)
   is represented by a pseudo-DIE of type DW_TAG_symbol.  It has the
   following attributes: @value, @size, @type, @bind, @visibility,
   @name, and @index.

   Instead of @index we'd like to have a @section which links to a
   pseudo-DIE representing a section.

   DW_FORM_addr -- maybe we should handle them similarly to
   readelf...?  Have a domain for addresses, and possibly (unless -N)
   translate addresses to symbols on output?

** XXX Dwarf CU version -- an artificial attribute?
   - https://stackoverflow.com/questions/16169864

** XXX abbreviation section?  (libdw doesn't have interfaces for this)
   - note that one can look for attribute form by saying (attribute
     ?@at form)
   - would a link from a DIE to its abbreviation be useful?

** XXX integrating aadr2line
   - low_pc and high_pc should be convertible to symbol name on
     request (possibly manually by cross-matching with ELF symtabs).

** XXX .debug_frame, .eh_frame
   - do we need an overarching "theory" for both of these?
   - also, there's fair amount of tables around here (symbol tables,
     line tables, ...).  Does it make sense to understand them as
     first-class citizen of some sort?  Currently we understand there
     are values, every value has some properties, and some values have
     attributes.

** XXX .debug_macro

** XXX nested identifier names
   currently we have to write
   : ?(@name "a" ?eq) child ?(@name "b" ?eq) child ?(@name "c" ?eq)
   which works, but is clumsy.  We'd much rather write something much
   less verbose.  It's not clear what, without cluttering the
   language.  If there were a library word, say lookup, meaning the
   following:
   : ?(0 (?(swap each ?(pos ?eq) @name over ?eq) 1 add rot child rot rot)*
   :   ?(swap length ?eq))

   We could use it thus:
   : ["a", "b", "c"] lookup

   : ["a", "b", "c"] ?(each first swap (?(@name ?eq) <child, next>)* )

   Or:
   : "a" ::@name "b" ::@name "c" ::@name
   where ::X would expand to:
   : ?(swap (X) ?eq) child
   -- but the final child doesn't work.  It seems the original awkward
   way of expressing this is the best one after all.

** XXX optional dwarf_attr_integrate
   - Currently we do that always for @at, ?@at etc.  Maybe it should
     be configurable.
     - It definitely should.  For things like ?@declaration you care
       about whether the DIE itself is a declaration, not that some
       @specification somewhere is (it obviously is...).

   - XXX "attribute" function should also consistently yield either
     only attributes at the DIE itself, or integrated attributes as
     well.

** XXX optional inlining of DW_TAG_partial unit
   - We don't interpret DW_TAG_imported_unit at all currently.
     Eventually we'll probably want to inline this by default, but
     also have a way to actually see the DW_TAG_imported_unit DIE's as
     well.

   - (Note that DW_TAG_imported_module and DW_TAG_imported_declaration
     are for "using namespace X" and "using X" respectively, so
     unrelated to this.)

** XXX multithreading
   - processing Dwarf has the potential for a lot of concurrency.  If
     locks end up serializing, we might actually open the Dwarf in
     each thread anew, and see if that helps.

* Examples

** Josh Stone's nontrivial-parameters script

   : ?subprogram !@declaration
   : ?(@decl_file ?("^/usr/" match) !("^/usr/src/debug" match))
   : -child ?formal_parameter
   : ?(@type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type)) swap
   : "%( -@decl_file %): %( -@decl_line %): note: in function \
   : `%( @name %)', parameter `%( @name %)' type is not trivial"

   - What the following XQuery really does:

   : ?subprogram !@declaration -child ?formal_parameter
   : ?(@type ((?const_type, ?volatile_type, ?typedef) @type)*
   :   (?structure_type, ?class_type)) 2/@name swap
   : "%s: type of parameter %s is not trivial."

   - In XQuery, it is actually not horrible, except for having to
     write the closure by hand:

   : declare function local:cvPeeledType($root, $node) {
   :     let $T := $root//*[@id = $node/at_type] return
   :     if ($T/name() = "tag_const_type"
   :         or $T/name() = "tag_volatile_type"
   :         or $T/name() = "tag_typedef")
   :     then local:cvPeeledType($root, $T)
   :     else $T
   : };
   :
   : //tag_subprogram/tag_formal_parameter/
   : (let $T := local:cvPeeledType(/, .)/name()
   :  where $T = "tag_structure_type"
   :  return concat (../at_name/text(), ": type of parameter ",
   :                 $A/at_name/text(), " is not trivial."))

** check_die_decl_call:

   : ( ?@decl_column !@decl_line "%s has decl_column, but NOT decl_line"
   : , etc.)

   - XQuery:

   : //at_decl_column[not(../at_decl_line)]/
   : concat(../@id, ": has decl_column, but NOT decl_line")

** check_die_line_info:

   : (?subprogram, ?inline_subroutine, ?entry_point, ?lexical_block,
   :  ?label, ?with_stmt, ?try_block, ?catch_block)
   : dup (@entry_pc, @low_pc, @ranges)
   : swap parent* ?root
   : !(@stmt_list @address ?eq) swap
   : "Address %s referenced from %s not found in line table."

** contains DW_OP_fbreg && ! @frame_base

   : !@frame_base ?(@location child @atom DW_OP_fbreg ?eq)

   - XQuery:

   : //at_location[loc_expr/loc_op/@op = "fbreg"][not(../../at_frame_base)]

** uses register based operators

   : ?(@location @atom (DW_OP_bregx ?eq, ?(DW_OP_reg0 ?ge) ?(DW_OP_regx ?le)))

   : ?(@location @atom "%s" "_b?reg" find)

** whether it uses a deref operator

   : ?(@location @atom (DW_OP_deref, DW_OP_xderef, DW_OP_deref_size,
   :                    DW_OP_xderef_size, DW_OP_GNU_deref_type) ?eq)

   : ?(@location @atom "%s" "deref" ?find)

   - XQuery:

   : //.[at_location//loc_op/(.[@op="deref_size" or @op="deref" or @op="xderef"
   :                            or @op="xderef_size" or @op="GNU_deref_type])]

   : //.[at_location//loc_op[contains(@op, "deref")]]

** contains DW_OP_call_frame_cfa && $@low_pc == 0

   : ?(@low_pc 0 ?eq) ?(@frame_base @atom DW_OP_call_frame_cfa ?eq)

   - something

   : if (@low_pc == 0 and @frame_base @atom == DW_OP_call_frame_cfa)

   - XQuery (note this matches @low_pc as text, not as number):

   : //.[at_low_pc/text() = "0x0"][at_frame_base//@op = "call_frame_cfa"]

** is an empty location expression

   : ?@location !(@location)

   - something

   : if (has @location and empty [@location])

   - XQuery:

   : //at_location[loc_expr[not(loc_op)]]

** location expression ends with implicit_value or stack_value

   : ?(@location ?last @atom (DW_OP_implicit_value, DW_OP_stack_value) ?eq)

   - something

   : if (@location, if last, if (@atom == DW_OP_implicit_value
   :                             or @atom == DW_OP_stack_value))

   - XQuery:

   : //.[at_location//.[last()]/
   :     (.[@op = "implicit_value" or @op = "stack_value"])]

** types inconsistent between instance and specification
   - http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43053

   : ?subprogram dup @specification 2/(child ?formal_parameter)
   : ?(2/pos ?eq) ?(2/@type !eq)

   - something:

   : if (is subprogram) with @specification 2/(child is formal_parameter)

   - XQuery:

   : for $x at $pos in //tag_subprogram[at_specification]/tag_formal_parameter
   : return //.[@id=$x/../at_specification/text()]/tag_formal_parameter
   :        [position() = $pos] [at_type/text() != $x/at_type/text()]

** duplicat DW_TAG_const_type
   - http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56740

   : -unit ?gt 2/(?const_type, ?volatile_type, ?restrict_type)
   : ?(2/tag ?eq) ?(2/@type ?eq)

   - XQuery:

   : for $x in (//tag_const_type | //tag_volatile_type | //tag_restrict_type)
   : return (//tag_const_type | //tag_volatile_type | //tag_restrict_type)
   : [@id != $x/@id][name() = $x/name()][at_type/text() = $x/at_type/text()]

** find any attribute with value "blah"

   : attribute ?(value "blah" ?eq)

   - XQuery:

   : //.[text()="blah"]

** check_duplicate_DW_tag_variable.cc
   Check for two full DW_TAG_variable DIEs with the same DW_AT_name
   value.

   : dup 2/(child ?variable) ?lt ?(2/@name ?eq)

   : dup next+ 2/?variable ?(2/@name ?eq)

** check_linkage_external_die.cc

   : ?symbol ?(@type (STT_OBJECT, STT_FUNC) ?eq) ?(@name !"")
   : winfo ?@linkage_name [-(@linkage_name swap @name ?eq)]
   :
   : ((if !@declaration !@const_value
   :   (!structure_type !enumeration_type !union_type, ?@name)
   :   "%s has linkage_name attribute that's not in symtab,\
   :   but is not marked as declaration"),
   :
   :  (else [-(swap @binding STB_LOCAL !eq)]
   :   (if !@declaration ?@external
   :    "%s has linkage_name attribute,\
   :    but the corresponding symbol is local"),
   :   (else !@external
   :    "%s has linkage_name attribute, but no external attribute")))

   This is still 1:10 vs. dwarflint C++ (i.e., say 1:20 if we had to
   explore the DIE tree by hand), but fairly involved.

   The interpreter would need to notice the ?symbol nodes are used as
   a sort of global variable for cross-referencing, otherwise this
   would lead to an ugly combinatorial explosion of states.  Noticing
   that we look at the bottom slot and cross-reference @name with
   @linkage_name should be possible.

** CU A imports two PU's B and C, and both import the same third PU

   : ?root dup dup 2/(CU ?imported_unit @import) ?lt
   : [-(2/(unit ?imported_unit @import) ?eq)] each ?first
   : "PU %s is imported by PU's %s and %s, which are both imported by %s"

   - What the following XQuery really does:

     : ?root ?(dup 2/(unit ?imported_unit @import) ?lt
     :             2/(unit ?imported_unit @import) ?eq)

   - XQuery:

     : for $u in //.[../name() = "debug_info"]
     : for $a in $u//tag_imported_unit
     : for $b in $u//tag_imported_unit
     : let $c := //.[@id=$a/at_import/text()]
     : let $d := //.[@id=$b/at_import/text()]
     : where $a/@id < $b/@id and $c//tag_imported_unit/at_import/text()
     :                         = $d//tag_imported_unit/at_import/text()
     : return $u

** typedef resolution
   - dsmith asked for a way to get typedef "resolution" from DWARF
     (for use with the syscall types in the kernel). Which was timely
     since I was just thinking about having some "roundtripping" tests
     for GCC/elfutils DWARF types. So hacked up a dwfltypedef that
     prints all (C) typedefs found:

     $ ./dwfltypedef -e ./dwfltypedef
     [2d] typedef size_t long unsigned int (unsigned, 8 bytes);
     [70] typedef __off_t long int (signed, 8 bytes);
     [7b] typedef __off64_t long int (signed, 8 bytes);
     [...]

     : winfo ?typedef dup @type (?typedef @type)* !typedef swap
     : "[%(-offset%)] typedef %(@name%) %(-@name%) \
     : (%((-@encoding, !@encoding "???")%), \
     : %((@byte_size, !@byte_size drop "???")%) bytes)"

     [0x57] typedef __int32_t int (DW_ATE_signed, 4 bytes)
     [0x70] typedef __off_t long int (DW_ATE_signed, 8 bytes)
     [0x7b] typedef __off64_t long int (DW_ATE_signed, 8 bytes)
     [0x9c] typedef __intptr_t long int (DW_ATE_signed, 8 bytes)
     [0xa7] typedef size_t long unsigned int (DW_ATE_unsigned, 8 bytes)
     [...]

