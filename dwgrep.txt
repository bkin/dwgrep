-*-org-*-
* Computation

  Dwgrep is tool and an associated language for expressing
  computations done on a Dwarf graph.  Conceptually expressions of
  this language form a pipeline of functions.  The Dwarf graph under
  consideration flows through this pipeline, and whatever comes out
  of the other end is the result of the computation.

  We call what flows through the dwgrep expression a /working set/.
  The elements of this set can by any of the following:

  - Dwarf DIE's
  - integers, strings
  - sequences of other values

  Initial working set contains all DIE's in a given Dwarf graph (and
  then some).

  Each function takes a working set on input, and is applied to each
  element of this input working set.  On the output, each application
  produces zero or more values, which are collected, and form the
  output working set.  So functions work as generalized filters that
  drop, mutate, or expand elements of working set.

  Functions in dwgrep expressions generally come in one of the
  following flavors:

  - predicates (keep elements for which the predicate holds, drop
    others)
  - traversals (replace one DIE with another (or a set thereof))
  - producers (replace Dwarf DIE's with values of other types)

  In following, examples are generally written as follows:

  : blah blah lorem ipsum stuff

  The initial colon is not part of the example, but an artifact of
  Emacs org mode.


* Introduction to the dwgrep language

** ?ID — a predicate that holds for DIE's whose tag is DW_TAG_ID

   To list all subprograms, one would use the following
   expression:

   : ?subprogram

** ?@ID — a predicate that holds for DIE's with an attribute DW_AT_ID
** PRED₁ && PRED₂, PRED₁ || PRED₂, !PRED — the usual logical connectives

   To list all subprograms that are not pure declarations, one would
   use the following:

   : ?subprogram && ! ?@declaration

** (EXPR) — we can parenthesize for clarity or precedence
** / — child traversal

   This function replaces every DIE with all its children.  Childless
   DIE's are thus dropped.  To get at the formal arguments of the
   subprograms from the previous example, one might say:

   : (?subprogram && ! ?@declaration) /

** EXPR₁ EXPR₂ … — pipeline formation

   In dwgrep, pipelines are formed by simply placing each function
   next to each other.  This can be seen in the previous example
   already: we placed / directly after the predicate.  Well, this
   principle holds universally.

   E.g. if we want to make sure that we really get only the formal
   parameter nodes in the above example, we might say this:

   : (?subprogram && ! ?@declaration) / ?formal_parameter

   Knowing this, we might also rewrite this example as follows:

   : ?subprogram (! ?@declaration) / ?formal_parameter

   ... but that's probably not very clear.

** $@x — value of attribute DW_AT_x

   This is the firet example of a function that can produces
   something else than Dwarf DIE's.  E.g. we could obtain names of
   the formal parameters selected above:

   : (?subprogram && ! ?@declaration) / ?formal_parameter $@name

   The result would be a set of strings with names of all formal
   parameters in the program.  That's not very useful (yet), but
   there's another use of this same feature:

** $@x — attribute edge traversal

   For reference attributes, the value of $@x (e.g. $@type) is the
   referenced DIE.  Hence in this case, $@x encodes traversal.  For
   example, we could get to types of formal parameters thus:

   : (?subprogram && ! ?@declaration) / ?formal_parameter $@type

   ... which is much more useful.  We might use this to discover
   whether there are formal parameters that have structure types, and
   would therefore incur a potentially expensive copy when the
   function is called:

   : (?subprogram && ! ?@declaration) / ?formal_parameter
   : $@type ?structure_type

   So that will let us know whether that is the case.  But that's not
   very useful--we want to know the exact context where this happens!
   Hence:

** ID := EXPR — name binding

   This can be used to remember a value, before further functions
   transform it.  The binding is remembered and carried along with a
   value, and survives value transformation unchanged.  Later on we
   can recall the value by saying:

** $ID — value recall

   This is again a function, but a degenerate one: it replaces any
   input argument with the previously-remembered value.

   We can use binding and recall together to get names of the
   functions with formal parameters of structure types:

   : A := (?subprogram && ! ?@declaration) / ?formal_parameter
   : $@type ?structure_type $A $@name

   So that's more useful.

   But this still shows only functions that take structure arguments
   directly.  But what if they take const arguments?  Or if they take
   a typedef that evaluates to a structure?  For these cases we need
   to keep peeling the fluff until we get to the interesting DIE's.
   Enter iterators:

** EXPR*, EXPR+, EXPR? — expression iteration
   - EXPR* leaves the input set unchanged, then adds to that the
     result of one application of EXPR, then of another, etc.  It
     works similarly to * in regular expressions.
   - EXPR+ is exactly like EXPR EXPR*
   - EXPR? is like EXPR*, but EXPR is only applied once

   We can use this tool to remove const_type, volatile_type and
   typedef peels from out potential structure:

   : A := (?subprogram && ! ?@declaration) / ?formal_parameter
   : $@type ((?const_type || ?volatile_type || ?typedef) $@type)*
   : ?structure_type $A $@name


* Overview of dwgrep language

** EXPR → EXPR₁ EXPR₂ … — pipeline formation

   - If an EXPR returns a list of values, it's as if it returned all
     the constituent elements individually.  If you wish to get an
     actual list of values instead, check out {}.
   - The rationale behind this rule is the behavior that we want "/"
     to have.

** EXPR → “(” EXPR₁ “)”

** EXPR → EXPR₁ “*” | EXPR₁ “+” | EXPR₁ “?” — iteration

** EXPR → “:@” ID | “$@”ID — attribute access

   - :@ID yields DW_AT_ID itself, as an attribute object.  See below
     for property access to see what this can be used for.
   - $@ID yields a value of DW_AT_ID.  This can be a string, a
     number, a sequence, or another DIE.  In the latter case, $@ID is
     effectively a graph traversal.

** EXPR → “/” | “/parent” | “/next” | “/prev” — traversal

** EXPR → EXPR₁ “,” EXPR₂ … — sequence constructor

   - This evaluates all constituent EXPR's with the same input and
     returns a sequence of results.  Note that returned sequences are
     normally all merged together (see the rule at pipeline
     formation).  See operator {} if you want to get actual
     sequences.

** EXPR → “{” EXPR₁ “}” | “{” “}” — sequence quoting

   - This takes the result of EXPR₁ and returns it as a sequence
     that's not expanded into individual values.
   - "{1, 2, 3}" stands for a list with three values, 1, 2 and 3.
   - "{/}" stands for list of immediate children
   - "{/*}" stands for list of all descendants
   - "{}" stands for empty list

** EXPR → PRED₁ — filtering

** EXPR → ID “:=” EXPR₁ — binding

   - The identifier together with current value is attached to a
     dictionary, which is stored with a working set element.  For
     purposes of pruning duplicate working set elements, attached
     bindings are considered as well.
   - This can be used to emulate for loops, kind of:
     : i := {1, 2, 3, 4} j := {1, 2, 3, 4} (mul $i, $j) ($i > $j)
     ... this should return:
     : 2, 3, 4, 6, 8, 12
   - Possibly imperative-style loops work as well:
     : A := 1 (A := (add $A, 1))*
     That's fairly disgusting and I'm not entirely sure whether and
     how exactly it works.
   - XXX how do we unbind, forget a name?  E.g. if we want to allow
     merging of final values and the name is not important anymore.

** EXPR → “$” ID — recall

** EXPR → “$_” — identity function

** EXPR → “$pos” — position of element in sequence or working set

** EXPR → “[” EXPR₁ “]” — ??? sugar for ($pos == (EXPR₁))???

** EXPR → “add” EXPR₁ | “sub” EXPR₁ | “mul” EXPR₁ | “div” EXPR₁ | “mod” EXPR₁ — math

   - We already use +, * and /, but math shouldn't be useful very
     often anyway, so it's done in this roundabout way.  Possibly use
     this for gt, ge, lt, le, eq, ne as well?
   - EXPR₁ yields a sequence of values, which are processed as if the
     operation corresponding to the instruction was between every two
     of them.  E.g. (add 1, 2, 3) results in 6, (sub 1, 2, 3) in -4.
   - If EXPR₁ returns a list of free-standing values instead of a
     quoted sequence, the behavior is the same.  So (add 1, 2, 3) is
     the same as (add {1, 2, 3}), is the same as (add (1, 2, 3)).
   - If you wish to process sequences in your working set, do
     e.g. (add $_).
   - XXX Hmm, but this doesn't need any special notation.  "add" is a
     function.  It adds whatever comes to input, and produces single
     value as result.  So (1, 2, 3) add, just like anything in this
     language.

** EXPR → “concat” EXPR₁ — sequence processing

** EXPR → “"” (string literal) “"” | (“0x”|“0”|“”)[1-9][0-9]* — literals

   - String literals will probably provide some form of value
     interpolation, so that one could say, e.g.:
     : A := X Y Z "blah blah %{$A%}"
     %{ and %} would probably enclose an EXPR that's evaluated on the
     input value to the string itself.  The we wouldn't need the
     string-formatting operator.
   - "%{ $_ %}" converts anything to a string, but we might have %s
     to save on typing.

** EXPR → “:” ID — value property access
   - This yields various values according to the type of input
     element:

     |------+------------+---------------------------------------------|
     | type | key        | meaning                                     |
     |------+------------+---------------------------------------------|
     | DIE  | type       | "DIE"                                       |
     | DIE  | tag        | integer value of tag                        |
     | DIE  | children   | sequence of DIE's.  Same as simply "/".     |
     | DIE  | attributes | sequence of AT's                            |
     | DIE  | offset     | integer denoting offset of DIE in file      |
     | DIE  | @ID        | like :attributes ($_ == DW_AT_ID)           |
     |------+------------+---------------------------------------------|
     | AT   | type       | "AT"                                        |
     | AT   | name       | integer value of attribute name             |
     | AT   | form       | integer value of form                       |
     | AT   | value      | attribute value (can be DIE, SEQ, INT, STR) |
     | AT   | offset     | integer denoting offset of AT in file       |
     |------+------------+---------------------------------------------|
     | SEQ  | type       | "SEQ"                                       |
     | SEQ  | length     | length of sequence                          |
     |------+------------+---------------------------------------------|
     | STR  | type       | "STR"                                       |
     | STR  | length     | length of string                            |
     |------+------------+---------------------------------------------|
     | INT  | type       | "INT"                                       |
     |------+------------+---------------------------------------------|

** PRED → “^” — root node predicate

   - Note that this is a predicate.  It is true on a root node, false
     otherwise.
   - (/parent* ^) -- finds a root node of current node
   - XXX possibly shorten this as "$^"?
   - XXX how about "universe"--set of all nodes?  Do we need to
     encode this as (/parent* ^ /*)?

** PRED → “?”ID — tag predicate

** PRED → “?@”ID — attribute presence predicate

** PRED → PRED₁ “&&” PRED₂ | PRED₁ “||” PRED₂ | “!” PRED₁ — logical connectives

** PRED → EXPR₁ “==” EXPR₂ | EXPR₁ “!=” EXPR₂ — equivalence

** PRED → EXPR₁ “<” EXPR₂ | EXPR₁ “>” EXPR₂ | EXPR₁ “<=” EXPR₂ | EXPR₁ “>=” EXPR₂ — comparison

** PRED → EXPR₁ “=~” EXPR₂ | EXPR₁ “!~” EXPR₂ — regex matching

   - EXPR₁ is a string to be match by regular expression at EXPR₂.

** PRED → “if” “(” EXPR₁ “)”

   - Unlike direct pipeline formation, EXPR₁ is evaluated as
     subexpression, and effects of traversal and filtering are kept
     locally and thrown away after EXPR₁ is evaluated.
   - Input of EXPR₁ is the same as input of the overall PRED.
   - The elements for which EXPR₁ evaluates to non-empty set are
     kept, others are rejected.

** PRED → “.show” | “.dump” — debugging

   - both predicates always succeed, and print elements that they are
     tested on.
     - .show shows only the value
     - .dump shows debugging information as well--fuller output,
       attached values, that sort of thing

* Representing non-.debug_info information

** @decl_file
   The value is represented as actual string including path.

** @stmt_list
   The value is a line table.  We model this as a bunch of nodes with
   attributes.  The nodes are of type line_table, and each has these
   attributes: @address, @op_index, @file, @line, @column, @is_stmt,
   @basic_block, @end_sequence, @prologue_end, @epilogue_begin, @isa,
   @discriminator.

** XXX location expressions?
  - probably a list of instructions
  - possibly a means of evaluating?

** ELF symbols

* Examples
** Josh Stone's nontrivial-types script

   : A := (?subprogram && ! ?@declaration
   :       && !($@decl_file =~ "^/usr/" && $@decl_file !~ "^/usr/src/debug"))
   : / B := ?formal_parameter
   : $@type ((const_type || volatile_type || typedef) $@type)*
   : (?structure_type || ?class_type)
   : (add "%{ $A $@decl_file %}:%{ $A $@decl_line %}: note: in function ",
   :      "`%{ $A $@name }%', parameter `%{ $B $@name %}' type is not trivial")

   - In XQuery, it is:

   : declare function local:cvPeeledType($root, $node) {
   :     let $T := $root//*[@id = $node/at_type] return
   :     if ($T/name() = "tag_const_type"
   :         or $T/name() = "tag_volatile_type"
   :         or $T/name() = "tag_typedef")
   :     then local:cvPeeledType($root, $T)
   :     else $T
   : };
   :
   : doc ("xxxxx.xml")//tag_subprogram/
   : (let $A := tag_formal_parameter
   :  let $T := local:cvPeeledType(/, $A)
   :  return if ($T/name() = "tag_structure_type")
   :         then concat ($A/../at_name/text(), ": type of parameter ",
   :                      $A/at_name/text(), " is not trivial.")
   : 	else ())

** check_die_decl_call:

   : ( (?@decl_column && !?@decl_line) "%s has decl_column, but NOT decl_line"
   : , (?decl_line && !?@decl_file) "%s has decl_line, but NOT decl_file"
   : , (?@decl_file && !?@decl_line) "%s has decl_file, but NOT decl_line"
   : , (?call_column && !?call_line) "%s has call_column, but NOT call_line"
   : , (?call_line && !?call_file) "%s has call_line, but NOT call_file"
   : , (?call_file && !?call_line) "%s has call_file, but NOT call_line" )

** check_die_line_info:

   : A := (?subprogram || ?inline_subroutine || ?entry_point || ?lexical_block
   :       || ?label || ?with_stmt || ?try_block || ?catch_block)
   : B := ($@entry_pc, $@low_pc, $@ranges)
   : /parent* ^
   : ({$@stmt_list ($A == $@address)} == {})
   : ("Address %s referenced form %s not found in line table." % {$B; $A})

** childless DIE's:
   : if (!/)
   ... at least I think ;)

* Mark's stuff
** contains DW_OP_fbreg && ! @frame_base

** uses register based operators

** whether it uses a deref operator

** contains DW_OP_call_frame_cfa && $@low_pc == 0

** is an empty location expression
** location expression ends with implicit_value or stack_value
* Old work
== check_duplicate_DW_tag_variable

--> check for two full DW_TAG_variable DIEs with the same DW_AT_name
    value

//variable[@declaration]

== check_linkage_external_die.cc

(SHT_DYNSYM | SHT_SYMTAB)/*[@type==STT_OBJECT or @type==STT_FUNC][@name != ""]
